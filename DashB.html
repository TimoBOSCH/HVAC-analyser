<!DOCTYPE html>
<html lang="nl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Warmtepomp Dashboard Pro</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'BoschSans', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            min-height: 100vh;
            padding: 20px;
            color: #2c3e50;
        }
        
        .container {
            max-width: 1600px;
            margin: 0 auto;
            background: #ffffff;
            border-radius: 0;
            overflow: hidden;
            min-height: calc(100vh - 40px);
            box-shadow: 0 0 40px rgba(0,0,0,0.08);
        }
        
        .header {
            background: linear-gradient(135deg, #E31E24 0%, #B71C1C 100%);
            color: white;
            padding: 40px 50px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            position: relative;
            overflow: hidden;
        }
        
        .header::before {
            content: '';
            position: absolute;
            top: 0;
            right: 0;
            width: 200px;
            height: 100%;
            background: linear-gradient(45deg, transparent 0%, rgba(255,255,255,0.1) 50%, transparent 100%);
            transform: skewX(-15deg);
        }
        
        .header h1 {
            font-size: 2.8em;
            margin: 0;
            font-weight: 300;
            letter-spacing: -1px;
            position: relative;
            z-index: 2;
        }
        
        .header h1::after {
            content: '';
            display: block;
            width: 60px;
            height: 4px;
            background: #00B4A6;
            margin-top: 10px;
        }
        
        .header-controls {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
        }
        
        .btn {
            padding: 14px 28px;
            border: none;
            border-radius: 0;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            text-decoration: none;
            display: inline-flex;
            align-items: center;
            gap: 10px;
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            position: relative;
            overflow: hidden;
        }
        
        .btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
            transition: left 0.5s;
        }
        
        .btn:hover::before {
            left: 100%;
        }
        
        .btn-primary {
            background: rgba(255,255,255,0.15);
            color: white;
            border: 2px solid rgba(255,255,255,0.3);
        }
        
        .btn-primary:hover {
            background: rgba(255,255,255,0.25);
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0,0,0,0.2);
        }
        
        .btn-success {
            background: #00B4A6;
            color: white;
            border: 2px solid #00B4A6;
        }
        
        .btn-success:hover {
            background: #009688;
            border-color: #009688;
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0,180,166,0.3);
        }
        
        .content {
            padding: 50px;
            background: #fafbfc;
        }
        
        .section {
            background: #ffffff;
            border-radius: 0;
            padding: 40px;
            margin-bottom: 40px;
            box-shadow: 0 2px 20px rgba(0,0,0,0.08);
            border-left: 5px solid #E31E24;
            position: relative;
        }
        
        .section::before {
            content: '';
            position: absolute;
            top: 0;
            right: 0;
            width: 100px;
            height: 5px;
            background: linear-gradient(90deg, #E31E24, #00B4A6, #0066CC);
        }
        
        .section h2 {
            font-size: 1.8em;
            margin-bottom: 25px;
            color: #2c3e50;
            display: flex;
            align-items: center;
            gap: 15px;
            cursor: pointer;
            user-select: none;
            font-weight: 300;
            letter-spacing: -0.5px;
        }
        
        .section h2:hover {
            color: #E31E24;
        }
        
        .file-upload {
            border: 3px dashed #2196F3;
            border-radius: 15px;
            padding: 40px;
            text-align: center;
            background: #f8f9ff;
            transition: all 0.3s ease;
        }
        
        .file-upload:hover {
            background: #f0f4ff;
            border-color: #1976D2;
        }
        
        .file-upload input {
            display: none;
        }
        
        .file-upload label {
            cursor: pointer;
            font-size: 1.1em;
            color: #2196F3;
            font-weight: 600;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .stat-card {
            background: linear-gradient(135deg, #E31E24 0%, #B71C1C 100%);
            color: white;
            padding: 30px;
            border-radius: 0;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
            border-left: 5px solid #00B4A6;
        }
        
        .stat-card::before {
            content: '';
            position: absolute;
            top: -50%;
            right: -50%;
            width: 100%;
            height: 200%;
            background: linear-gradient(45deg, transparent 40%, rgba(255,255,255,0.1) 50%, transparent 60%);
            transform: rotate(25deg);
            transition: all 0.5s ease;
            opacity: 0;
        }
        
        .stat-card:hover::before {
            opacity: 1;
            transform: rotate(25deg) translateX(100%);
        }
        
        .stat-card:hover {
            transform: translateY(-8px);
            box-shadow: 0 12px 30px rgba(227,30,36,0.3);
        }
        
        .stat-card:nth-child(2) {
            background: linear-gradient(135deg, #0066CC 0%, #004499 100%);
            border-left-color: #E31E24;
        }
        
        .stat-card:nth-child(2):hover {
            box-shadow: 0 12px 30px rgba(0,102,204,0.3);
        }
        
        .stat-card:nth-child(3) {
            background: linear-gradient(135deg, #00B4A6 0%, #009688 100%);
            border-left-color: #0066CC;
        }
        
        .stat-card:nth-child(3):hover {
            box-shadow: 0 12px 30px rgba(0,180,166,0.3);
        }
        
        .stat-card:nth-child(4) {
            background: linear-gradient(135deg, #6A1B9A 0%, #4A148C 100%);
            border-left-color: #00B4A6;
        }
        
        .stat-card:nth-child(4):hover {
            box-shadow: 0 12px 30px rgba(106,27,154,0.3);
        }
        
        .stat-value {
            font-size: 2.2em;
            font-weight: bold;
            margin-bottom: 8px;
        }
        
        .stat-label {
            font-size: 0.9em;
            opacity: 0.9;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .filters-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
        }
        
        .filter-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .filter-group label {
            font-weight: 600;
            color: #333;
            font-size: 0.9em;
        }
        
        .filter-group select,
        .filter-group input {
            padding: 12px;
            border: 2px solid #e1e1e1;
            border-radius: 8px;
            font-size: 14px;
            transition: border-color 0.3s ease;
        }
        
        .filter-group select:focus,
        .filter-group input:focus {
            outline: none;
            border-color: #2196F3;
        }
        
        .multiselect {
            max-height: 120px;
            overflow-y: auto;
            border: 2px solid #e1e1e1;
            border-radius: 8px;
            padding: 10px;
            background: #f9f9f9;
        }
        
        .multiselect-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
            padding: 8px;
            background: #f0f4ff;
            border-radius: 6px;
            border: 1px solid #e1e1e1;
        }
        
        .multiselect-btn {
            padding: 4px 12px;
            border: none;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .multiselect-btn.select-all {
            background: #00B4A6;
            color: white;
        }
        
        .multiselect-btn.select-all:hover {
            background: #009688;
        }
        
        .multiselect-btn.deselect-all {
            background: #E31E24;
            color: white;
        }
        
        .multiselect-btn.deselect-all:hover {
            background: #B71C1C;
        }
        
        .multiselect label {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 4px 0;
            font-weight: normal;
            cursor: pointer;
        }
        
        .charts-grid {
            display: grid;
            grid-template-columns: 1fr; /* E√©n kolom - onder elkaar */
            gap: 40px;
        }
        
        .chart-container {
            background: white;
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }
        
        .chart-controls {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
            flex-wrap: wrap;
            align-items: center;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 10px;
        }
        
        .chart-controls select {
            padding: 8px 12px;
            border: 2px solid #e1e1e1;
            border-radius: 6px;
            font-size: 13px;
            min-width: 120px;
        }
        
        .chart-controls label {
            font-size: 13px;
            font-weight: 600;
            color: #555;
        }
        
        .chart-canvas {
			position: relative;
			height: 800px; /* Consistente hoogte voor alle charts */
			width: 100%; /* Volledige breedte van container */
			min-width: 1400px; /* Minimum breedte voor betere leesbaarheid */
			max-width: 1400px; /* Maximum breedte om overstretching te voorkomen */
			margin: 30px 0 20px 0;
			overflow: hidden; /* Voorkomt dat labels buiten de container gaan */
		}
        
        /* Custom chart legend above each chart */
        .chart-legend-custom {
			display: flex;
			justify-content: center; /* Centreer de legend items */
			align-items: center; /* Verticaal centreren */
			gap: 15px;
			margin: 10px 0 20px 0; /* Minder marge voor compacte weergave */
			padding: 12px;
			background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%); /* Subtiele gradient */
			border-radius: 10px;
			overflow-x: auto;
			white-space: nowrap;
			scroll-behavior: smooth;
			border: 2px solid #dee2e6;
			box-shadow: 0 2px 8px rgba(0,0,0,0.08); /* Subtiele schaduw */
			min-height: 50px; /* Minimum hoogte om lege legends zichtbaar te maken */
		}
        
        .chart-legend-custom::-webkit-scrollbar {
            height: 6px;
        }
        
        .chart-legend-custom::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 10px;
        }
        
        .chart-legend-custom::-webkit-scrollbar-thumb {
            background: #2196F3;
            border-radius: 10px;
        }
        
        .chart-legend-custom::-webkit-scrollbar-thumb:hover {
            background: #1976D2;
        }
        
        .chart-legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 13px;
            font-weight: 500;
            flex-shrink: 0;
            padding: 8px 12px;
            border-radius: 8px;
            background: white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            cursor: pointer;
            transition: all 0.2s ease;
            border: 2px solid transparent;
        }
        
        .chart-legend-item:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.15);
        }
        
        .chart-legend-item.hidden {
            opacity: 0.4;
            border-color: #ddd;
        }
        
        .chart-legend-dot {
            width: 14px;
            height: 14px;
            border-radius: 50%;
            border: 2px solid #fff;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            flex-shrink: 0;
        }
        
        /* Hide the built-in Chart.js legend */
        .chart-canvas .chartjs-legend,
        .chart-canvas .legend {
            display: none !important;
        }
        
        .color-legend {
            display: flex;
            gap: 15px;
            margin-top: 15px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 10px;
            overflow-x: auto;
            white-space: nowrap;
            scroll-behavior: smooth;
        }
        
        .color-legend::-webkit-scrollbar {
            height: 8px;
        }
        
        .color-legend::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 10px;
        }
        
        .color-legend::-webkit-scrollbar-thumb {
            background: #2196F3;
            border-radius: 10px;
        }
        
        .color-legend::-webkit-scrollbar-thumb:hover {
            background: #1976D2;
        }
        
        .color-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 13px;
            font-weight: 500;
            flex-shrink: 0;
            padding: 5px 10px;
            border-radius: 8px;
            background: white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .color-dot {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            border: 2px solid #fff;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        
        .chart-title {
            text-align: center;
            font-size: 1.2em;
            font-weight: 600;
            color: #333;
            margin-bottom: 15px;
            padding: 10px;
            background: #f0f4ff;
            border-radius: 8px;
        }
        
        .add-chart-btn {
            background: #f0f4ff;
            border: 3px dashed #2196F3;
            border-radius: 15px;
            padding: 60px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .add-chart-btn:hover {
            background: #e8f2ff;
            border-color: #1976D2;
        }
        
        .loading {
            text-align: center;
            padding: 60px;
            color: #666;
        }
        
        .loading-spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #2196F3;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .export-buttons {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }
        
        .range-input {
            width: 100%;
            margin: 10px 0;
        }
        
        .range-values {
            display: flex;
            justify-content: space-between;
            font-size: 12px;
            color: #666;
            margin-top: 5px;
        }
        
        /* Products Overview Styles */
        .products-overview {
            background: white;
            border-radius: 15px;
            padding: 0;
            overflow: hidden;
        }
        
        .products-header {
            background: linear-gradient(45deg, #4CAF50, #45A049);
            color: white;
            padding: 20px 30px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .products-content {
            padding: 30px;
        }
        
        .products-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }
        
        /* Product selection styles */
        .product-card {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 12px;
            border: 1px solid #e1e1e1;
            transition: all 0.3s ease;
            position: relative;
            font-size: 13px;
        }
        
        .product-card:hover {
            border-color: #2196F3;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }
        
        .product-card.selectable {
            cursor: pointer;
            user-select: none;
            border: 2px solid #e1e1e1;
        }
        
        .product-card.selectable:hover {
            border-color: #2196F3;
            transform: translateY(-4px);
            box-shadow: 0 8px 25px rgba(33, 150, 243, 0.3);
        }
        
        .product-card.selected {
            border: 3px solid #4CAF50 !important;
            background: linear-gradient(135deg, #f8fff8 0%, #e8f5e8 100%);
            transform: translateY(-4px);
            box-shadow: 0 8px 25px rgba(76, 175, 80, 0.4);
        }
        
        .product-card.selected::before {
            content: '\2713';
            position: absolute;
            top: 8px;
            left: 8px;
            background: #4CAF50;
            color: white;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 14px;
            z-index: 10;
        }
        
        .selection-controls {
            margin: 20px 0;
            padding: 15px;
            background: #f0f4ff;
            border-radius: 10px;
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .selection-info {
            background: #e3f2fd;
            padding: 10px 15px;
            border-radius: 8px;
            margin: 10px 0;
            border-left: 4px solid #2196F3;
            font-weight: 600;
        }
        
        .selection-info.active {
            background: #e8f5e8;
            border-left-color: #4CAF50;
            color: #2e7d32;
        }
        
        .product-brand {
            position: absolute;
            top: 8px;
            right: 10px;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 10px;
            font-weight: 600;
            color: white;
        }
        
        .product-title {
            font-size: 12px;
            font-weight: 700;
            margin-bottom: 10px;
            font-size: 16px;
            text-overflow: ellipsis;
            max-height: 32px;
            overflow: hidden;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            line-clamp: 2;
            -webkit-box-orient: vertical;
        }
        
        .product-details {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 6px;
            margin-bottom: 8px;
            font-size: 11px;
        }
        
        .product-detail {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 2px 0;
        }
        
        .product-detail-label {
            font-size: 10px;
            color: #666;
            text-transform: uppercase;
            font-weight: 600;
        }
        
        .product-detail-value {
            font-size: 11px;
            font-weight: 600;
            color: #333;
        }
        
        .product-price {
            background: linear-gradient(45deg, #2196F3, #21CBF3);
            color: white;
            padding: 6px;
            border-radius: 6px;
            text-align: center;
            font-size: 14px;
            font-weight: bold;
        }
        
        .products-summary {
            background: #e3f2fd;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
        }
        
        .summary-item {
            text-align: center;
        }
        
        .summary-value {
            font-size: 1.5em;
            font-weight: 600;
            color: #1976D2;
        }
        
        .summary-label {
            font-size: 12px;
            text-transform: uppercase;
            color: #666;
            margin-top: 5px;
        }
        
        .powerbi-info {
            background: linear-gradient(45deg, #FF6B35, #F7931E);
            color: white;
            padding: 25px;
            border-radius: 15px;
            margin-top: 20px;
        }
        
        .powerbi-info h3 {
            margin-bottom: 15px;
            font-size: 1.3em;
        }
        
        .powerbi-steps {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }
        
        .powerbi-step {
            background: rgba(255,255,255,0.2);
            padding: 15px;
            border-radius: 10px;
            text-align: center;
        }
        
        .powerbi-step-number {
            background: white;
            color: #FF6B35;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            margin: 0 auto 10px;
        }
        
        @media (max-width: 768px) {
            .charts-grid {
                grid-template-columns: 1fr; /* Blijft 1 kolom op mobiel */
                gap: 20px; /* Minder ruimte op mobiel */
            }
            
            .chart-canvas {
                height: 350px; /* Lagere hoogte op mobiel */
            }
            
            .filters-grid {
                grid-template-columns: 1fr;
            }
            
            .header {
                flex-direction: column;
                gap: 20px;
            }
            
            .chart-controls {
                flex-direction: column;
                align-items: stretch;
            }
            
            .products-grid {
                grid-template-columns: 1fr;
            }
            
            .color-legend {
                flex-wrap: nowrap;
            }
        }
        
        .hidden {
            display: none;
        }
        
        .edit-mode .chart-container {
            border: 2px dashed #2196F3;
        }
        
        .remove-chart-btn {
            background: #ff4444;
            color: white;
            border: none;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            cursor: pointer;
            font-size: 16px;
            position: absolute;
            top: 10px;
            right: 10px;
        }
        
        .chart-container {
            position: relative;
        }

        .status-box {
            padding: 20px;
            background: #e3f2fd;
            border-radius: 10px;
            margin-bottom: 20px;
        }

        .status-box h3 {
            margin: 0 0 10px 0;
            color: #1976D2;
        }

        .status-box p {
            margin: 5px 0;
            color: #666;
        }

        .status-success {
            background: #e8f5e8;
        }

        .status-error {
            background: #ffebee;
        }

        .status-warning {
            background: #fff3cd;
        }

        /* AI Filter Controls */
        .ai-filter-controls {
            display: flex;
            gap: 8px;
            margin-top: 8px;
            align-items: center;
        }

        .ai-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 6px;
            padding: 6px 12px;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .ai-btn:hover {
            background: linear-gradient(135deg, #5a6fd8 0%, #6a4190 100%);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
        }

        .ai-input {
            flex: 1;
            padding: 8px 12px;
            border: 2px solid #e1e1e1;
            border-radius: 6px;
            font-size: 12px;
            background: #f8f9fa;
        }

        .ai-status {
            font-size: 11px;
            margin-top: 4px;
            padding: 4px 8px;
            border-radius: 4px;
            display: none;
        }

        .ai-status.success {
            background: #d4edda;
            color: #155724;
            display: block;
        }

        .ai-status.error {
            background: #f8d7da;
            color: #721c24;
            display: block;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Pricemirror Dashboard</h1>
            <div class="header-controls">
                <button class="btn btn-warning" onclick="resetAllFilters()">üîÑ Reset Filters</button>
                <button class="btn btn-warning" onclick="restoreFilterState()">‚Ü©Ô∏è Ongedaan maken</button>
                <button class="btn btn-success" onclick="exportToCSV()">üìä Export CSV</button>
                <button class="btn btn-success" onclick="exportToJSON()">üìÑ Export JSON</button>
                <button class="btn btn-primary" onclick="toggleEditMode()">
                    <span id="editModeText">‚öôÔ∏è Configureer</span>
                </button>
            </div>
        </div>
        
        <div class="content">
            <!-- Data Loading Status -->
            <div class="section">
                <h2>üîÑ Data Status</h2>
                
                <!-- Auto-loading from JSONBin -->
                <div id="autoLoadSection">
                    <div class="status-box" id="statusBox">
                        <h3>üì° Automatisch Data Laden via JSONBin</h3>
                        <p>Dashboard ID: <strong><span id="dashboardIdDisplay">Wachten...</span></strong></p>
                        <p>Status: <strong><span id="dataLoadStatus">Verbinden met JSONBin...</span></strong></p>
                        
                        <div style="margin-top: 15px;">
                            <button class="btn btn-primary" onclick="loadDashboardData()" style="margin-right: 10px; background: #000; border-color: #000;">
                                üîÑ Refresh Data
                            </button>
                            <button class="btn btn-primary" onclick="toggleAutoRefresh()" style="background: #000; border-color: #000;">
                                <span id="autoRefreshText" style="color: #fff;">‚è∞ Start Auto-refresh</span>
                            </button>
                        </div>
                    </div>
                    
                    <div id="loadingIndicator" class="loading">
                        <div class="loading-spinner"></div>
                        <p>Zoeken naar je data in JSONBin...</p>
                        <small style="color: #666;">Dashboard zoekt elke 10 seconden naar nieuwe data</small>
                    </div>
                </div>
                
                <!-- Manual upload fallback -->
                <div id="manualUploadSection" class="hidden">
                    <div class="status-box status-warning">
                        <strong>‚ö†Ô∏è Manual Upload Mode</strong><br>
                        <small>Geen dashboard ID gevonden. Upload handmatig een CSV bestand.</small>
                    </div>
                    
                    <div class="file-upload">
                        <input type="file" id="csvFile" accept=".csv" />
                        <label for="csvFile">
                            üîÑ Klik hier om je warmtepomp CSV te uploaden<br>
                            <small style="color: #666;">Ondersteund: CSV bestanden</small>
                        </label>
                    </div>
                </div>
                
                <div id="dataInfo" class="hidden" style="margin-top: 20px; padding: 15px; background: #e8f5e8; border-radius: 8px;">
                    <span id="dataStatus"></span>
                </div>
            </div>
            
            <!-- Statistics -->
            <div id="statsSection" class="section hidden">
                <h2 onclick="showProductsOverview()">üìä Statistieken (Klik voor producten overzicht)</h2>
                <div class="stats-grid">
                    <div class="stat-card" onclick="showProductsOverview()">
                        <div class="stat-value" id="totalProducts">0</div>
                        <div class="stat-label">Totaal Producten</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="totalBrands">0</div>
                        <div class="stat-label">Merken</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="avgPrice">‚Ç¨0</div>
                        <div class="stat-label">Gem. Prijs</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="priceRange">‚Ç¨0 - ‚Ç¨0</div>
                        <div class="stat-label">Prijsbereik</div>
                    </div>
                </div>
            </div>
            
            <!-- Products Overview -->
            <div id="productsSection" class="section hidden">
                <div class="products-overview">
                    <div class="products-header">
                        <h2 style="margin: 0; color: white;">üè† Warmtepomp Producten Overzicht</h2>
                        <button class="btn btn-primary" onclick="hideProductsOverview()">‚ùå Sluiten</button>
                    </div>
                    <div class="products-content">
                        <div class="products-summary" id="productsSummary"></div>
                        <div class="products-grid" id="productsGrid"></div>
                    </div>
                </div>
            </div>
            
            <!-- Filters -->
            <div id="filtersSection" class="section hidden">
                <h2>üîç Filters</h2>
                <div id="filtersGrid" class="filters-grid"></div>
            </div>
            
            <!-- Color Legend -->
            <div id="colorLegendSection" class="section hidden">
                <h2>  Merken </h2>
                <div id="colorLegend" class="color-legend"></div>
            </div>
            
            <!-- Charts -->
            <div id="chartsSection" class="section hidden">
                <h2>üìà Interactieve Grafieken</h2>
                <div id="chartsGrid" class="charts-grid"></div>
            </div>
        </div>
    </div>

    <script>
        // Global variables
        let originalData = [];
        let selectedProducts = new Set(); // Houdt geselecteerde product IDs bij
        let productSelectionMode = false; // Of selectie mode actief is
        let filteredData = [];
        let columns = [];
        let activeFilters = {};
        let charts = [];
        let editMode = false;
        let brandColors = {};
        let chartInstances = {};
        let autoRefreshInterval;
        let dashboardId = null;
		let productLabelsEnabled = {}; // Track which charts have labels enabled
        
        // AI Transformation System
        let columnTransformations = {}; // Stores AI transformations per column
        let transformedColumns = new Set(); // Track which columns have been AI-transformed

        // OpenAI API Configuration
        const OPENAI_CONFIG = {
            API_KEY: getApiKey('OPENAI_CONFIG') || '',
            MODEL: 'gpt-4.1-mini',
            BASE_URL: 'https://api.openai.com/v1/chat/completions'
        };
        
        // JSONBin API Configuration
        const JSONBIN_CONFIG = {
            API_KEY: getApiKey('JSONBIN_CONFIG') || '',
            BASE_URL: 'https://api.jsonbin.io/v3'
        };
        
        // Dashboard ID to Bin ID mapping (alleen voor speciale gevallen)
        const DASHBOARD_BIN_MAPPING = {
            'analysis_1748426064924_9hltvpjou': '6836dd948561e97a501c8237',
            // Voeg alleen speciale mappings toe als nodig
        };
        
        // Color palette
        const COLOR_PALETTE = [
            '#3B82F6', '#EF4444', '#10B981', '#F59E0B', '#8B5CF6', 
            '#EC4899', '#14B8A6', '#F97316', '#6366F1', '#84CC16',
            '#F43F5E', '#06B6D4', '#8B5A2B', '#7C3AED', '#059669',
            '#DC2626', '#CA8A04', '#9333EA', '#0891B2', '#65A30D'
        ];
		
		// Detecteer of kolom numeriek is
		function isNumericColumn(columnName) {
			if (!columnName || !originalData || originalData.length === 0) {
				console.log(`‚ö†Ô∏è isNumericColumn: Invalid input - columnName: ${columnName}, dataLength: ${originalData ? originalData.length : 0}`);
				return false;
			}
			
			// Specifieke kolommen die altijd categorisch zijn
			const categoricalColumns = ['merk', 'brand', 'type', 'model', 'energielabel', 'materiaal', 'kleur', 'naam', 'name'];
			if (categoricalColumns.includes(columnName.toLowerCase())) {
				console.log(`üè∑Ô∏è ${columnName} is categorisch (bekende kolom)`);
				return false;
			}
			
			// Specifieke kolommen die altijd numeriek zijn  
			const numericColumns = ['prijs', 'price', 'vermogen', 'power', 'gewicht', 'weight', 'kw', 'watt'];
			if (numericColumns.includes(columnName.toLowerCase())) {
				console.log(`üìä ${columnName} is numeriek (bekende kolom)`);
				return true;
			}
			
			const values = originalData.map(item => item[columnName]).filter(val => val !== null && val !== undefined && val !== '');
			if (values.length === 0) {
				console.log(`‚ö†Ô∏è ${columnName} heeft geen waarden`);
				return false;
			}
			
			// Check of meer dan 70% van de waarden numeriek zijn (verlaagd van 80%)
			const numericValues = values.filter(val => {
				const num = Number(val);
				return !isNaN(num) && val !== '' && typeof val !== 'boolean';
			});
			
			const numericPercentage = numericValues.length / values.length;
			const isNumeric = numericPercentage > 0.7;
			
			console.log(`üìä ${columnName}: ${numericValues.length}/${values.length} numeriek (${Math.round(numericPercentage * 100)}%) ‚Üí ${isNumeric ? 'NUMERIEK' : 'CATEGORISCH'}`);
			
			return isNumeric;
		}

		// Detecteer of kolom categorisch is
		function isCategoricalColumn(columnName) {
			return !isNumericColumn(columnName);
		}

		// üëá NIEUWE FUNCTIE HIER TOEVOEGEN:
		function getValidColumnsForAxis(chartType, axisType) {
			// TIJDELIJK: toon altijd alle kolommen om te debuggen
			console.log(`üîç getValidColumnsForAxis: ${chartType}, ${axisType}`);
			console.log(`üìã Beschikbare kolommen:`, columns);
			
			if (!columns || columns.length === 0) {
				console.log('‚ö†Ô∏è Geen kolommen beschikbaar');
				return [];
			}
			
			// Toon alle kolommen (geen filtering) om te testen
			return columns;
		}

// Hierna komt de rest van de code (document.addEventListener etc.)
        
        // Initialize
        document.addEventListener('DOMContentLoaded', function() {
            setupFileUpload();
            initializeDefaultCharts();
            
            // Check if we have a dashboard ID in URL
            const urlParams = new URLSearchParams(window.location.search);
            const urlDashboardId = urlParams.get('id');
            const urlBinId = urlParams.get('bin');
            
            if (urlBinId) {
                // Direct bin ID provided
                dashboardId = urlBinId;
                document.getElementById('dashboardIdDisplay').textContent = `Bin: ${urlBinId.substring(0, 12)}...`;
                loadDashboardData();
                // Start auto-refresh
                toggleAutoRefresh();
            } else if (urlDashboardId && urlDashboardId !== 'dashboard.html') {
                // Check if we have a mapping for this dashboard ID
                const mappedBinId = DASHBOARD_BIN_MAPPING[urlDashboardId];
                if (mappedBinId) {
                    dashboardId = mappedBinId;
                    document.getElementById('dashboardIdDisplay').textContent = `${urlDashboardId} ‚Üí ${mappedBinId.substring(0, 12)}...`;
                    loadDashboardData();
                    // Start auto-refresh
                    toggleAutoRefresh();
                } else {
                    // Legacy dashboard ID provided without mapping
                    dashboardId = urlDashboardId;
                    document.getElementById('dashboardIdDisplay').textContent = dashboardId;
                    loadDashboardData();
                    // Start auto-refresh
                    toggleAutoRefresh();
                }
            } else {
                // Show manual upload section
                showManualUpload();
            }
        });
        
        function showManualUpload() {
            document.getElementById('autoLoadSection').classList.add('hidden');
            document.getElementById('manualUploadSection').classList.remove('hidden');
            document.getElementById('dashboardIdDisplay').textContent = 'Niet beschikbaar';
            document.getElementById('dataLoadStatus').textContent = 'Manual upload mode';
        }
        
        // Load dashboard data from JSONBin
        async function loadDashboardData() {
            if (!dashboardId) {
                console.log('Geen dashboard ID beschikbaar');
                return false;
            }
            
            try {
                document.getElementById('dataLoadStatus').textContent = 'Verbinden met opgegeven data bron...';
                document.getElementById('statusBox').className = 'status-box';
                
                console.log('Loading data for dashboard ID:', dashboardId);
                
                // Clean the dashboard ID thoroughly (remove pipes, brackets, spaces, etc.)
                let cleanBinId = dashboardId
                    .replace(/^[\|\[\]]+/, '')  // Remove leading pipes, brackets
                    .replace(/[\|\[\]]+$/, '')  // Remove trailing pipes, brackets
                    .replace(/[^0-9a-f]/gi, '') // Keep only hex characters
                    .trim();
                
                console.log('Cleaned Bin ID:', cleanBinId);
                
                // Very flexible Bin ID detection - if it looks like hex and is long enough, try it
                if (/^[0-9a-f]+$/i.test(cleanBinId) && cleanBinId.length >= 20) {
                    console.log('ID lijkt op een Bin ID, proberen te laden...');
                    return await loadDirectBinData(cleanBinId);
                }
                
                // For non-bin IDs, use the direct mapping
                const mappedBinId = DASHBOARD_BIN_MAPPING[dashboardId];
                if (mappedBinId) {
                    console.log(`Dashboard ID ${dashboardId} gemapped naar Bin ID: ${mappedBinId}`);
                    return await loadDirectBinData(mappedBinId);
                }
                
                // If nothing works, show helpful error
                throw new Error(`Geen geldige Bin ID gevonden. Origineel: "${dashboardId}", Cleaned: "${cleanBinId}". Gebruik format: dashboard.html?bin=YOUR_FULL_BIN_ID`);
                
            } catch (error) {
                console.error('Error loading dashboard data:', error);
                document.getElementById('dataLoadStatus').textContent = `‚ùå ${error.message}`;
                document.getElementById('statusBox').className = 'status-box status-error';
                
                // Show manual upload after 5 seconds
                setTimeout(() => {
                    if (originalData.length === 0) {
                        showManualUpload();
                    }
                }, 5000);
                
                return false;
            }
        }
        
        // Load data directly from a specific Bin ID
        async function loadDirectBinData(binId) {
            try {
                document.getElementById('dataLoadStatus').textContent = `üéØ Laden van specifieke Bin: ${binId.substring(0, 8)}...`;
                console.log(`üéØ Direct loading from specified Bin ID: ${binId}`);
                
                const dataResponse = await fetch(`${JSONBIN_CONFIG.BASE_URL}/b/${binId}`, {
                    headers: {
                        'X-Master-Key': JSONBIN_CONFIG.API_KEY
                    }
                });
                
                if (!dataResponse.ok) {
                    if (dataResponse.status === 404) {
                        throw new Error(`Bin ID ${binId} niet gevonden. Controleer of de Bin ID correct is.`);
                    } else if (dataResponse.status === 401) {
                        throw new Error(`Geen toegang tot Bin ${binId}. Controleer API permissions.`);
                    } else {
                        throw new Error(`HTTP ${dataResponse.status} fout bij laden van Bin ${binId}`);
                    }
                }
                
                const binData = await dataResponse.json();
                console.log(`‚úÖ Direct bin data received from ${binId}:`, binData);
                
                if (binData.record && binData.record.processed_data && binData.record.processed_data.length > 0) {
                    document.getElementById('dataLoadStatus').textContent = `‚úÖ Data geladen van Bin ${binId.substring(0, 8)}! (${binData.record.processed_data.length} items)`;
                    document.getElementById('statusBox').className = 'status-box status-success';
                    document.getElementById('loadingIndicator').classList.add('hidden');
                    
                    // Extract the JSON from the N8N format
                    const warmtepompen = binData.record.processed_data.map(item => item.json);
                    console.log(`‚úÖ Processed ${warmtepompen.length} warmtepompen from specific bin:`, warmtepompen);
                    
                    processDataFromN8N(warmtepompen);
                    
                    return true;
                } else if (binData.record) {
                    // Try to use the record data directly if no processed_data
                    console.log('Geen processed_data gevonden, proberen directe record data...');
                    
                    if (Array.isArray(binData.record)) {
                        console.log('Record is array, direct gebruiken...');
                        processDataFromN8N(binData.record);
                        return true;
                    } else if (typeof binData.record === 'object') {
                        console.log('Record is object, als array behandelen...');
                        processDataFromN8N([binData.record]);
                        return true;
                    }
                    
                    throw new Error(`Bin ${binId} gevonden maar bevat geen bruikbare data structuur`);
                } else {
                    throw new Error(`Bin ${binId} gevonden maar bevat geen record data`);
                }
                
            } catch (error) {
                console.error(`‚ùå Error loading direct bin data from ${binId}:`, error);
                document.getElementById('dataLoadStatus').textContent = `‚ùå ${error.message}`;
                document.getElementById('statusBox').className = 'status-box status-error';
                return false;
            }
        }
        
        function setupFileUpload() {
            const fileInput = document.getElementById('csvFile');
            if (fileInput) {
                fileInput.addEventListener('change', handleFileUpload);
            }
        }
        
        // Process data from N8N
        function processDataFromN8N(data) {
            console.log('Processing data from N8N:', data);
            
            // Convert N8N data to the format we expect
            originalData = Array.isArray(data) ? data : [data];
            
            // Clean data
            originalData = originalData.filter(row => 
                row && typeof row === 'object' && 
                Object.values(row).some(val => val !== null && val !== undefined && val !== '')
            );
            
            if (originalData.length === 0) {
                alert('Geen geldige data ontvangen van JSONBin');
                return;
            }
            
            // Normalize column names (convert spaces to lowercase)
            originalData = originalData.map(item => {
                const normalized = {};
                Object.keys(item).forEach(key => {
                    // Convert "Product Naam" to "merk", "Vermogen" to "vermogen", etc.
                    let normalizedKey = key.toLowerCase();
                    if (key === 'Product Naam') normalizedKey = 'merk';
                    if (key === 'Vermogen') normalizedKey = 'vermogen';
                    if (key === 'Prijs') normalizedKey = 'prijs';
                    if (key === 'Model') normalizedKey = 'model';
                    if (key === 'Gewicht') normalizedKey = 'gewicht';
                    
                    normalized[normalizedKey] = item[key];
                });
                return normalized;
            });
            
            // Get columns
            columns = Object.keys(originalData[0]);
            filteredData = [...originalData];
            
            console.log('Columns found:', columns);
            console.log('Data processed:', originalData.length, 'items');
            
            // Generate brand colors
            generateBrandColors();
			console.log('üìä Brand colors generated:', Object.keys(brandColors).length, 'brands');
            
            // Update UI
            updateDataInfo();
            updateStatistics();
            createFilters();
            updateColorLegend();
            initializeCharts();
            
            // Show sections
            document.getElementById('statsSection').classList.remove('hidden');
            document.getElementById('filtersSection').classList.remove('hidden');
            document.getElementById('colorLegendSection').classList.remove('hidden');
            document.getElementById('chartsSection').classList.remove('hidden');
            
            console.log(`‚úÖ Dashboard geladen met ${originalData.length} producten`);
        }
        
        function toggleAutoRefresh() {
            if (autoRefreshInterval) {
                // Stop auto-refresh
                clearInterval(autoRefreshInterval);
                autoRefreshInterval = null;
                document.getElementById('autoRefreshText').textContent = '‚è∞ Start Auto-refresh';
                console.log('Auto-refresh gestopt');
            } else {
                // Start auto-refresh (every 10 seconds)
                autoRefreshInterval = setInterval(() => {
                    console.log('Auto-refresh: checking for new data...');
                    loadDashboardData();
                }, 10000);
                document.getElementById('autoRefreshText').textContent = '‚è∏Ô∏è Stop Auto-refresh';
                console.log('Auto-refresh gestart (elke 10 seconden)');
            }
        }
        
        function handleFileUpload(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            Papa.parse(file, {
                complete: function(results) {
                    if (results.data && results.data.length > 0) {
                        processData(results.data);
                    }
                },
                header: true,
                dynamicTyping: true,
                skipEmptyLines: true,
                error: function(error) {
                    alert('Error bij het laden van CSV: ' + error.message);
                }
            });
        }
        
        function processData(data) {
            // Clean data
            originalData = data.filter(row => 
                Object.values(row).some(val => val !== null && val !== undefined && val !== '')
            );
            
            if (originalData.length === 0) {
                alert('Geen geldige data gevonden in CSV');
                return;
            }
            
            // Get columns
            columns = Object.keys(originalData[0]);
            filteredData = [...originalData];
            
            // Generate brand colors
            generateBrandColors();
            
            // Update UI
            updateDataInfo();
            updateStatistics();
            createFilters();
            updateColorLegend();
            initializeCharts();
            
            // Show sections
            document.getElementById('statsSection').classList.remove('hidden');
            document.getElementById('filtersSection').classList.remove('hidden');
            document.getElementById('colorLegendSection').classList.remove('hidden');
            document.getElementById('chartsSection').classList.remove('hidden');
        }
        
        function generateBrandColors() {
			// Validatie: zorg dat we data hebben
			const dataToUse = (filteredData && filteredData.length > 0) ? filteredData : 
							  (originalData && originalData.length > 0) ? originalData : [];
			
			if (dataToUse.length === 0) {
				console.warn('Geen data beschikbaar voor brand colors');
				brandColors = {};
				return;
			}
			
			// Haal merken op met uitgebreide fallbacks
			const brands = [...new Set(dataToUse.map(item => {
				if (!item || typeof item !== 'object') return null;
				
				return item.merk || item.brand || item.Brand || item.Merk || 
					   item.manufacturer || item.Manufacturer || item.fabrikant || 
					   item.Fabrikant || item.leverancier || item.Leverancier ||
					   'Onbekend'; // Fallback voor items zonder merk
			}).filter(Boolean))];
			
			console.log('üé® Generating colors for brands:', brands);
			
			// Reset brandColors en genereer nieuwe kleuren
			brandColors = {};
			
			if (brands.length === 0) {
				// Fallback: maak tenminste √©√©n kleur voor 'Onbekend'
				brandColors['Onbekend'] = COLOR_PALETTE[0];
				console.warn('Geen merken gevonden, gebruikt fallback kleur');
			} else {
				brands.forEach((brand, index) => {
					brandColors[brand] = COLOR_PALETTE[index % COLOR_PALETTE.length];
					console.log(`üé® Brand "${brand}" -> Color: ${brandColors[brand]}`);
				});
			}
			
			console.log('üé® Final brandColors object:', brandColors);
		}
			
        function updateDataInfo() {
            const info = document.getElementById('dataInfo');
            const status = document.getElementById('dataStatus');
            status.textContent = `‚úÖ ${originalData.length} rijen geladen | Kolommen: ${columns.join(', ')}`;
            info.classList.remove('hidden');
        }
        
        function updateStatistics() {
            const validPrices = originalData.filter(item => item.prijs).map(item => Number(item.prijs));
            const brands = [...new Set(originalData.map(item => item.merk).filter(Boolean))];
            
            document.getElementById('totalProducts').textContent = originalData.length;
            document.getElementById('totalBrands').textContent = brands.length;
            
            if (validPrices.length > 0) {
                const avgPrice = validPrices.reduce((sum, price) => sum + price, 0) / validPrices.length;
                const minPrice = Math.min(...validPrices);
                const maxPrice = Math.max(...validPrices);
                
                document.getElementById('avgPrice').textContent = `‚Ç¨${Math.round(avgPrice)}`;
                document.getElementById('priceRange').textContent = `‚Ç¨${Math.round(minPrice)} - ‚Ç¨${Math.round(maxPrice)}`;
            }
        }
        
        // Products Overview Functions
        function showProductsOverview() {
            updateProductsOverview();
            document.getElementById('productsSection').classList.remove('hidden');
            document.getElementById('productsSection').scrollIntoView({ behavior: 'smooth' });
        }
        
        function hideProductsOverview() {
            document.getElementById('productsSection').classList.add('hidden');
        }
        
        function updateProductsOverview() {
            // Only update if products section is visible
            if (document.getElementById('productsSection').classList.contains('hidden')) {
                return;
            }
            
            const summary = document.getElementById('productsSummary');
            const grid = document.getElementById('productsGrid');
            
            // Create summary
            const validPrices = filteredData.filter(item => item.prijs).map(item => Number(item.prijs));
            const brands = [...new Set(filteredData.map(item => item.merk).filter(Boolean))];
            const avgPrice = validPrices.length > 0 ? validPrices.reduce((sum, price) => sum + price, 0) / validPrices.length : 0;
            const topBrand = brands.reduce((top, brand) => {
                const count = filteredData.filter(item => item.merk === brand).length;
                return count > (filteredData.filter(item => item.merk === top).length || 0) ? brand : top;
            }, brands[0] || 'Onbekend');
            
            // Add selection controls
            const selectionControls = `
                <div class="selection-controls">
                    <button class="btn btn-primary" onclick="toggleProductSelectionMode()" 
                            style="background: ${productSelectionMode ? '#4CAF50' : '#2196F3'}; border-color: ${productSelectionMode ? '#4CAF50' : '#2196F3'};">
                        ${productSelectionMode ? '‚úì Selectie Actief' : 'üéØ Start Selectie'}
                    </button>
                    
                    ${productSelectionMode ? `
                        <button class="btn btn-success" onclick="selectAllVisibleProducts()">‚úì Alles Selecteren</button>
                        <button class="btn" onclick="clearProductSelection()" style="background: #ff4444; color: white; border-color: #ff4444;">‚úó Wissen</button>
                        <button class="btn btn-primary" onclick="applyProductSelection()" style="background: #FF6B35; border-color: #FF6B35;">üìä Filter Diagrammen</button>
                    ` : ''}
                    
                    <div class="selection-info ${selectedProducts.size > 0 ? 'active' : ''}">
						üìã ${selectedProducts.size} van ${filteredData.length} producten geselecteerd
						${selectedProducts.size > 0 ? ' Klik "Filter Diagrammen" om alleen geselecteerde producten te tonen' : ''}
					</div>
                </div>
            `;
            
            summary.innerHTML = selectionControls + `
                <div class="products-summary" style="margin-top: 20px;">
                    <div class="summary-item">
                        <div class="summary-value">${filteredData.length}</div>
                        <div class="summary-label">Gefilterde Producten</div>
                    </div>
                    <div class="summary-item">
                        <div class="summary-value">${brands.length}</div>
                        <div class="summary-label">Beschikbare Merken</div>
                    </div>
                    <div class="summary-item">
                        <div class="summary-value">‚Ç¨${Math.round(avgPrice)}</div>
                        <div class="summary-label">Gemiddelde Prijs</div>
                    </div>
                    <div class="summary-item">
                        <div class="summary-value">${topBrand}</div>
                        <div class="summary-label">Populairste Merk</div>
                    </div>
                </div>
            `;
            
            // Create product cards with all specifications
            grid.innerHTML = filteredData.map((product, index) => {
                const brandColor = brandColors[product.merk] || '#6B7280';
                const productName = (() => {
                    // Eerst proberen de meest waarschijnlijke velden
                    const directFields = [
                        product.model, 
                        product.naam, 
                        product.name,
                        product.title,
                        product.productNaam, 
                        product['product naam'],
                        product.product_name,
                        product.productname,
                        product.description,
                        product.omschrijving,
                        product.type
                    ].find(field => field && typeof field === 'string' && field.trim().length > 0);
                    
                    if (directFields) return directFields.trim();
                    
                    // Als directe velden niet werken, zoek naar elk veld dat 'naam', 'name', 'title', 'model' bevat
                    const nameFields = Object.keys(product).filter(key => 
                        (key.toLowerCase().includes('naam') || 
                         key.toLowerCase().includes('name') || 
                         key.toLowerCase().includes('title') || 
                         key.toLowerCase().includes('model') ||
                         key.toLowerCase().includes('product')) &&
                        product[key] && 
                        typeof product[key] === 'string' && 
                        product[key].trim().length > 2
                    );
                    
                    if (nameFields.length > 0) {
                        return product[nameFields[0]].trim();
                    }
                    
                    // Als laatste redmiddel, neem het eerste niet-lege string veld dat geen URL/ID is
                    const fallbackField = Object.entries(product).find(([key, value]) => 
                        typeof value === 'string' && 
                        value.length > 3 && 
                        !key.toLowerCase().includes('url') &&
                        !key.toLowerCase().includes('id') &&
                        !key.toLowerCase().includes('link') &&
                        !value.match(/^https?:\/\//) && // Geen URLs
                        !value.match(/^\d+$/) && // Geen pure nummers
                        value !== product.merk // Niet hetzelfde als merk
                    );
                    
                    return fallbackField ? fallbackField[1].trim() : 'Warmtepomp Product';
                })();
                const productId = `product_${index}_${productName.replace(/[^a-zA-Z0-9]/g, '_')}`;
                const isSelected = selectedProducts.has(productId);
                
                // Verzamel ALLE beschikbare specificaties
                const allSpecs = [];
                // Prepare all available product details
                const details = [];
                
                // Loop through all properties of the product
                Object.entries(product).forEach(([key, value]) => {
                    // Skip empty values, URLs, and specific keys we don't want to show
                    if (!value || typeof value === 'object' || 
                        ['id', 'url', 'index', 'source', 'merk', 'model', 'naam', 'type', 'prijs', 'productNaam', 'product naam'].includes(key.toLowerCase())) {
                        return;
                    }
                    
                    // Format the label nicely
                    const label = key.charAt(0).toUpperCase() + key.slice(1)
                        .replace(/([A-Z])/g, ' $1')
                        .replace(/_/g, ' ');
                    
                    // Format the value based on common fields
                    let formattedValue = value;
                    if (key.toLowerCase().includes('vermogen')) formattedValue = `${value} kW`;
                    else if (key.toLowerCase().includes('gewicht')) formattedValue = `${value} kg`;
                    else if (key.toLowerCase().includes('geluid')) formattedValue = `${value} dB`;
                    else if (key.toLowerCase().includes('temperatuur')) formattedValue = `${value}¬∞C`;
                    else if (key.toLowerCase().includes('prijs')) formattedValue = `‚Ç¨${Math.round(Number(value))}`;
                    
                    details.push(`
                        <div class="product-detail">
                            <span class="product-detail-label">${label}</span>
                            <span class="product-detail-value">${formattedValue}</span>
                        </div>
                    `);
                });
                
                return `
                    <div class="product-card ${productSelectionMode ? 'selectable' : ''} ${isSelected ? 'selected' : ''}" 
                         data-product-id="${productId}" 
                         ${productSelectionMode ? 'onclick="toggleProductSelection(this)"' : ''}>
                        <div class="product-brand" style="background-color: ${brandColor}">
                            ${product.merk || 'Onbekend'}
                        </div>
                        <div class="product-title" title="${productName}">
                            ${productName}
                        </div>
                        <div class="product-details">
                            ${details.slice(0, 10).join('')}
                        </div>
                        ${product.prijs ? `
                            <div class="product-price">‚Ç¨${Math.round(Number(product.prijs))}</div>
                        ` : '<div class="product-price">Prijs op aanvraag</div>'}
                    </div>
                `;
            }).join('');
        }
        
        function createFilters() {
			console.log('üîç createFilters aangeroepen');
			console.log('üìã Columns array:', columns);
			console.log('üìä Data sample:', originalData ? originalData[0] : 'Geen data');
			
			// Test kolom detectie
			if (columns && columns.length > 0) {
				columns.forEach(col => {
					const isNum = isNumericColumn(col);
					console.log(`üìä ${col}: ${isNum ? 'NUMERIEK' : 'CATEGORISCH'}`);
				});
			}
			
			const filtersGrid = document.getElementById('filtersGrid');
			filtersGrid.innerHTML = '';
			
			columns.forEach(column => {
                const uniqueValues = [...new Set(originalData.map(item => item[column]).filter(Boolean))];
                const isNumeric = uniqueValues.every(val => !isNaN(Number(val)));
                
                const filterGroup = document.createElement('div');
                filterGroup.className = 'filter-group';
                
                const label = document.createElement('label');
                label.textContent = column.charAt(0).toUpperCase() + column.slice(1);
                filterGroup.appendChild(label);

                // Add AI controls for each filter
                const aiControls = document.createElement('div');
                aiControls.className = 'ai-filter-controls';
                
                // Create AI button (avoid using innerHTML with event handlers)
                const aiBtn = document.createElement('button');
                aiBtn.className = 'ai-btn';
                aiBtn.textContent = 'ü§ñ AI';
                aiBtn.addEventListener('click', function() {
                    toggleAITransform(column);
                });
                
                // Create input field
                const aiInput = document.createElement('input');
                aiInput.type = 'text';
                aiInput.className = 'ai-input';
                aiInput.id = `ai-input-${column}`;
                aiInput.placeholder = 'bijv: converteer naar nummers, verwijder kW';
                aiInput.style.display = 'none';
                
                // Create apply button
                const applyBtn = document.createElement('button');
                applyBtn.className = 'ai-btn';
                applyBtn.id = `ai-apply-${column}`;
                applyBtn.textContent = '‚úì Apply';
                applyBtn.style.display = 'none';
                applyBtn.addEventListener('click', function() {
                    applyAITransform(column);
                });
                
                // Add keypress handler to input field for pressing Enter
                aiInput.addEventListener('keypress', function(event) {
                    if (event.key === 'Enter') {
                        applyAITransform(column);
                    }
                });
                
                // Append all elements
                aiControls.appendChild(aiBtn);
                aiControls.appendChild(aiInput);
                aiControls.appendChild(applyBtn);
                
                // Create status field
                const aiStatus = document.createElement('div');
                aiStatus.className = 'ai-status';
                aiStatus.id = `ai-status-${column}`;
                
                console.log(`AI controls created for column: ${column}`);

                filterGroup.appendChild(aiControls);
                filterGroup.appendChild(aiStatus);
                
                if (isNumeric && uniqueValues.length > 10000) {
                    // Range slider for numeric values
                    const min = Math.min(...uniqueValues.map(Number));
                    const max = Math.max(...uniqueValues.map(Number));
                    
                    const input = document.createElement('input');
                    input.type = 'range';
                    input.className = 'range-input';
                    input.min = min;
                    input.max = max;
                    input.value = max;
                    input.addEventListener('input', (e) => updateFilter(column, {min, max: Number(e.target.value)}));
                    
                    const values = document.createElement('div');
                    values.className = 'range-values';
                    values.innerHTML = `<span>${min}</span><span id="${column}_value">${max}</span>`;
                    
                    input.addEventListener('input', (e) => {
                        document.getElementById(`${column}_value`).textContent = e.target.value;
                    });
                    
                    filterGroup.appendChild(input);
                    filterGroup.appendChild(values);
                } else if (uniqueValues.length <= 10000) {
                    // Multiselect for categorical values with select all/deselect all buttons
                    const multiselectControls = document.createElement('div');
                    multiselectControls.className = 'multiselect-controls';
                    
                    const selectAllBtn = document.createElement('button');
                    selectAllBtn.className = 'multiselect-btn select-all';
                    selectAllBtn.textContent = '‚úì Alles';
                    selectAllBtn.onclick = () => selectAllValues(column);
                    
                    const deselectAllBtn = document.createElement('button');
                    deselectAllBtn.className = 'multiselect-btn deselect-all';
                    deselectAllBtn.textContent = '‚úó Niets';
                    deselectAllBtn.onclick = () => deselectAllValues(column);
                    
                    multiselectControls.appendChild(selectAllBtn);
                    multiselectControls.appendChild(deselectAllBtn);
                    
                    const multiselect = document.createElement('div');
                    multiselect.className = 'multiselect';
                    multiselect.dataset.column = column;
                    
                    uniqueValues.forEach(value => {
                        const checkboxLabel = document.createElement('label');
                        checkboxLabel.innerHTML = `
                            <input type="checkbox" value="${value}" data-column="${column}" checked>
                            <span>${value}</span>
                        `;
                        checkboxLabel.addEventListener('change', updateMultiselectFilter);
                        multiselect.appendChild(checkboxLabel);
                    });
                    
                    filterGroup.appendChild(multiselectControls);
                    filterGroup.appendChild(multiselect);
                } else {
                    // Dropdown for many values
                    const select = document.createElement('select');
                    select.innerHTML = `<option value="">Alle ${column}</option>`;
                    
                    uniqueValues.forEach(value => {
                        select.innerHTML += `<option value="${value}">${value}</option>`;
                    });
                    
                    select.addEventListener('change', (e) => updateFilter(column, e.target.value));
                    filterGroup.appendChild(select);
                }
                
                filtersGrid.appendChild(filterGroup);
            });
        }
        
        function selectAllValues(column) {
            const multiselect = document.querySelector(`[data-column="${column}"]`);
            const checkboxes = multiselect.querySelectorAll('input[type="checkbox"]');
            
            checkboxes.forEach(checkbox => {
                checkbox.checked = true;
            });
            
            // Clear the filter for this column (all selected = no filter)
            delete activeFilters[column];
            applyFilters();
        }
        
        function deselectAllValues(column) {
            const multiselect = document.querySelector(`[data-column="${column}"]`);
            const checkboxes = multiselect.querySelectorAll('input[type="checkbox"]');
            
            checkboxes.forEach(checkbox => {
                checkbox.checked = false;
            });
            
            // Set filter to empty array (nothing selected)
            activeFilters[column] = [];
            applyFilters();
        }
        
        function updateFilter(column, value) {
            if (value === '' || (typeof value === 'object' && value.max === Math.max(...originalData.map(item => Number(item[column]))))) {
                delete activeFilters[column];
            } else {
                activeFilters[column] = value;
            }
            applyFilters();
        }
        
        function updateMultiselectFilter(event) {
            const column = event.target.dataset.column;
            const value = event.target.value;
            const checked = event.target.checked;
            
            console.log(`Filter update: ${column} = ${value}, checked: ${checked}`);
            
            // Initialize filter if it doesn't exist - start with ALL values selected
            if (!activeFilters[column]) {
                const multiselect = document.querySelector(`[data-column="${column}"]`);
                const allCheckboxes = multiselect.querySelectorAll('input[type="checkbox"]');
                activeFilters[column] = [];
                
                // Add all currently checked values
                allCheckboxes.forEach(cb => {
                    if (cb.checked) {
                        activeFilters[column].push(cb.value);
                    }
                });
            }
            
            if (checked) {
                // Add value if not already in array
                if (!activeFilters[column].includes(value)) {
                    activeFilters[column].push(value);
                }
            } else {
                // Remove value from array
                activeFilters[column] = activeFilters[column].filter(v => v !== value);
            }
            
            // Check if all values are now selected
            const multiselect = document.querySelector(`[data-column="${column}"]`);
            const totalCheckboxes = multiselect.querySelectorAll('input[type="checkbox"]').length;
            
            if (activeFilters[column].length === totalCheckboxes) {
                // All values selected = remove filter (show everything)
                console.log(`All ${column} values selected, removing filter (show all)`);
                delete activeFilters[column];
            } else if (activeFilters[column].length === 0) {
                // No values selected = keep empty filter (show nothing)
                console.log(`No ${column} values selected, keeping empty filter (show nothing)`);
                // Keep the empty array
            } else {
                console.log(`${column} filter contains ${activeFilters[column].length}/${totalCheckboxes} values:`, activeFilters[column]);
            }
            
            console.log('All active filters:', activeFilters);
            
            applyFilters();
        }
        
        function applyFilters() {
            console.log('=== APPLYING FILTERS ===');
            console.log('Original data count:', originalData.length);
            console.log('Active filters:', activeFilters);
            
            filteredData = originalData.filter(item => {
                const passes = Object.entries(activeFilters).every(([column, filterValue]) => {
                    let itemValue = item[column];
                    
                    if (Array.isArray(filterValue)) {
                        // Multiselect filter
                        if (filterValue.length === 0) {
                            // No values selected = show nothing
                            return false;
                        }
                        
                        // Check if this is a numeric column (vermogen, prijs, gewicht, etc.)
                        const isNumericColumn = column.toLowerCase().includes('prijs') || 
                                              column.toLowerCase().includes('vermogen') || 
                                              column.toLowerCase().includes('gewicht') ||
                                              column.toLowerCase().includes('kw') ||
                                              !isNaN(Number(filterValue[0])); // Check if first filter value is numeric
                        
                        let passes;
                        if (isNumericColumn) {
                            // Convert both to numbers for comparison
                            const numItemValue = Number(itemValue);
                            passes = filterValue.some(filterVal => Number(filterVal) === numItemValue);
                            if (!passes) {
                                console.log(`Item filtered out by ${column} (numeric): ${numItemValue} not in [${filterValue.map(v => Number(v)).join(', ')}]`);
                            }
                        } else {
                            // String comparison
                            passes = filterValue.includes(itemValue);
                            if (!passes) {
                                console.log(`Item filtered out by ${column} (string): "${itemValue}" not in [${filterValue.join(', ')}]`);
                            }
                        }
                        
                        return passes;
                    } else if (typeof filterValue === 'object' && 'min' in filterValue) {
                        // Range filter
                        const numValue = Number(itemValue);
                        const passes = numValue >= filterValue.min && numValue <= filterValue.max;
                        if (!passes) {
                            console.log(`Item filtered out by ${column} range: ${numValue} not between ${filterValue.min}-${filterValue.max}`);
                        }
                        return passes;
                    } else {
                        // Single value filter - also handle numeric comparison
                        const isNumericFilter = !isNaN(Number(filterValue));
                        let passes;
                        
                        if (isNumericFilter) {
                            passes = Number(itemValue) === Number(filterValue);
                        } else {
                            passes = itemValue === filterValue;
                        }
                        
                        if (!passes) {
                            console.log(`Item filtered out by ${column}: "${itemValue}" !== "${filterValue}"`);
                        }
                        return passes;
                    }
                });
                
                return passes;
            });
            
            console.log(`Filtered data count: ${filteredData.length}`);
            console.log('=== FILTER COMPLETE ===');
            
            // Update all visual components
            updateStatistics();
            updateProductsOverview();
            updateColorLegend();
            updateAllCharts();
        }
        
        function updateAllCharts() {
			console.log('üîÑ Updating all charts with filtered data...');
			
			// Eerst brand colors regenereren met huidige data
			generateBrandColors();
			
			// Wacht even om zeker te zijn dat brandColors klaar is
			setTimeout(() => {
				// Update elk chart individueel
				charts.forEach(chart => {
					if (chart.xAxis && chart.yAxis) {
						console.log(`Updating chart ${chart.id}: ${chart.type} (${chart.xAxis} vs ${chart.yAxis})`);
						try {
							renderChart(chart);
						} catch (error) {
							console.error(`Error updating chart ${chart.id}:`, error);
						}
					}
				});
				
				// Update color legend na alle charts
				setTimeout(() => {
					updateColorLegend();
				}, 100);
				
			}, 50); // Kleine delay om race conditions te voorkomen
		}
        
        function updateColorLegend() {
			const legend = document.getElementById('colorLegend');
			
			// Gebruik gefilterde data als die beschikbaar is
			const dataToUse = filteredData.length > 0 ? filteredData : originalData;
			
			// Haal merken op met fallback opties
			const brands = [...new Set(dataToUse.map(item => {
				return item.merk || item.brand || item.Brand || item.Merk || 
					   item.manufacturer || item.Manufacturer || item.fabrikant;
			}).filter(Boolean))];
			
			console.log('üè∑Ô∏è Updating color legend for brands:', brands);
			
			if (brands.length === 0) {
				legend.innerHTML = '<div class="color-item"><span>Geen merken gevonden</span></div>';
				return;
			}
			
			legend.innerHTML = brands.map(brand => {
				const color = brandColors[brand] || '#6B7280';
				console.log(`üè∑Ô∏è Brand "${brand}" -> Color: ${color}`);
				
				return `
					<div class="color-item">
						<div class="color-dot" style="background-color: ${color}"></div>
						<span>${brand}</span>
					</div>
				`;
			}).join('');
		}
        
        function initializeDefaultCharts() {
			charts = [
				{ id: '1', type: 'scatter', xAxis: '', yAxis: '' },
				{ id: '2', type: 'bar', xAxis: '', yAxis: '' },
				{ id: '3', type: 'bubble', xAxis: '', yAxis: '' },
				{ id: '4', type: 'horizontalBar', xAxis: '', yAxis: '' }
			];
		}
				
        function initializeCharts() {
            renderChartsGrid();
        }
        
        function renderChartsGrid() {
            const grid = document.getElementById('chartsGrid');
            grid.innerHTML = '';
            
            charts.forEach(chart => {
                const chartContainer = createChartContainer(chart);
                grid.appendChild(chartContainer);
            });
            
            if (editMode) {
                const addButton = document.createElement('div');
                addButton.className = 'add-chart-btn';
                addButton.innerHTML = '‚ûï Nieuwe Grafiek';
                addButton.onclick = addChart;
                grid.appendChild(addButton);
            }
            
            updateAllCharts();
        }
        
        function createChartContainer(chart) {
            const container = document.createElement('div');
            container.className = 'chart-container';
            container.id = `chart-${chart.id}`;
            
            container.innerHTML = `
                ${editMode ? `<button class="remove-chart-btn" onclick="removeChart('${chart.id}')">√ó</button>` : ''}
                <div class="chart-controls">
                    <label>Type:</label>
                    <select onchange="updateChart('${chart.id}', 'type', this.value)">
						<optgroup label="Numerieke Charts">
							<option value="scatter" ${chart.type === 'scatter' ? 'selected' : ''}>Scatter Plot (Num ‚Üî Num)</option>
							<option value="bubble" ${chart.type === 'bubble' ? 'selected' : ''}>Bubble Chart (Num ‚Üî Num)</option>
						</optgroup>
						<optgroup label="Gemengde Charts">
							<option value="bar" ${chart.type === 'bar' ? 'selected' : ''}>Verticale Staaf (Cat ‚Üí Num)</option>
							<option value="horizontalBar" ${chart.type === 'horizontalBar' ? 'selected' : ''}>Horizontale Staaf (Cat ‚Üí Num)</option>
							<option value="categoricalScatter" ${chart.type === 'categoricalScatter' ? 'selected' : ''}>Categorische Scatter (Cat ‚Üí Num)</option>
							<option value="horizontalCategorical" ${chart.type === 'horizontalCategorical' ? 'selected' : ''}>Horizontaal Categorisch (Num ‚Üí Cat)</option>
						</optgroup>
						<optgroup label="Categorische Charts">
							<option value="heatmap" ${chart.type === 'heatmap' ? 'selected' : ''}>Heatmap (Cat ‚Üî Cat)</option>
						</optgroup>
					</select>
                    
                    <label>X-as:</label>
					<select onchange="updateChart('${chart.id}', 'xAxis', this.value)" id="xaxis-${chart.id}">
						<option value="">-- Kies X-as --</option>
						${columns.map(col => `<option value="${col}" ${chart.xAxis === col ? 'selected' : ''}>${col} ${isNumericColumn(col) ? '(üìä)' : '(üè∑Ô∏è)'}</option>`).join('')}
					</select>

					<label>Y-as:</label>
					<select onchange="updateChart('${chart.id}', 'yAxis', this.value)" id="yaxis-${chart.id}">
						<option value="">-- Kies Y-as --</option>
						${columns.map(col => `<option value="${col}" ${chart.yAxis === col ? 'selected' : ''}>${col} ${isNumericColumn(col) ? '(üìä)' : '(üè∑Ô∏è)'}</option>`).join('')}
					</select>
                    
                    ${chart.type === 'bubble' ? `
                        <label>Grootte:</label>
                        <select onchange="updateChart('${chart.id}', 'sizeBy', this.value)">
                            <option value="">-- Kies grootte --</option>
                            ${columns.filter(col => {
                                const firstValue = originalData[0]?.[col];
                                return !isNaN(Number(firstValue));
                            }).map(col => `<option value="${col}" ${chart.sizeBy === col ? 'selected' : ''}>${col}</option>`).join('')}
                        </select>
                    ` : ''}
					${chart.type === 'scatter' || chart.type === 'bubble' ? `
						<label>Product Labels:</label>
						<button class="btn btn-primary" onclick="toggleProductLabels('${chart.id}')" 
								id="labelToggle-${chart.id}" 
								style="background: #666; border-color: #666; padding: 8px 16px; font-size: 12px;">
							üè∑Ô∏è Toon Labels
						</button>
					` : ''}
                </div>
                
                <div class="chart-title">${chart.xAxis || 'X-as'} vs ${chart.yAxis || 'Y-as'}</div>
				<div class="chart-legend-custom" id="legend-${chart.id}"></div>
				<div class="chart-canvas">
					<canvas id="canvas-${chart.id}"></canvas>
				</div>
            `;
            
            return container;
        }
        
        function updateChart(chartId, field, value) {
					const chart = charts.find(c => c.id === chartId);
					if (chart) {
						chart[field] = value;
						renderChart(chart);
						
						// Update title
						const titleElement = document.querySelector(`#chart-${chartId} .chart-title`);
						if (titleElement) {
							titleElement.textContent = `${chart.xAxis || 'X-as'} vs ${chart.yAxis || 'Y-as'}`;
						}
					}
				}
				
				function renderChart(chart) {
			const canvas = document.getElementById(`canvas-${chart.id}`);
			if (!canvas || !chart.xAxis || !chart.yAxis) {
				console.warn(`Cannot render chart ${chart.id}: missing canvas or axes`);
				return;
			}
			
			// Zorg dat brandColors bestaat voordat we beginnen
			if (!brandColors || Object.keys(brandColors).length === 0) {
				console.log('Regenerating brand colors before chart render...');
				generateBrandColors();
			}
			
			// Destroy existing chart
			if (chartInstances[chart.id]) {
				chartInstances[chart.id].destroy();
			}
			
			const ctx = canvas.getContext('2d');
			const data = prepareChartData(chart);
			
			
			// Valideer data
			if (!data || !data.datasets || data.datasets.length === 0) {
				console.warn(`No data available for chart ${chart.id}`);
				// Toon lege chart met bericht
				ctx.clearRect(0, 0, canvas.width, canvas.height);
				ctx.fillStyle = '#666';
				ctx.font = '16px Arial';
				ctx.textAlign = 'center';
				ctx.fillText('Geen data beschikbaar', canvas.width/2, canvas.height/2);
				return;
			}
			
			let chartConfig = {
                type: chart.type === 'horizontalBar' ? 'bar' : chart.type,
                data: data,
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    indexAxis: chart.type === 'horizontalBar' ? 'y' : 'x',
                    plugins: {
                        legend: {
                            display: false // Disable built-in legend
                        },
                        tooltip: {
							mode: 'index',
							intersect: false,
							callbacks: {
								title: function(context) {
									const xValue = context[0].label;
									const dataPoint = context[0].raw;
									
									// Voor categorische data, toon originele waarde
									const xDisplay = dataPoint.originalX || dataPoint.xLabel || xValue;
									return `${chart.xAxis}: ${xDisplay}`;
								},
								
								label: function(context) {
									const dataPoint = context.raw;
									let value = context.parsed.y;
									
									// Voor categorische Y-as
									const yDisplay = dataPoint.originalY || dataPoint.yLabel || value;
									
									if (chart.type === 'heatmap') {
										return `Aantal: ${dataPoint.count}`;
									}
									
									// Bestaande logica voor numerieke waardes
									if (chart.yAxis === 'prijs' || chart.yAxis.toLowerCase().includes('prijs')) {
										return `üí∞ Gemiddelde prijs: ‚Ç¨${Math.round(value).toLocaleString()}`;
									} else if (chart.yAxis === 'vermogen') {
										return `‚ö° Gemiddeld vermogen: ${Math.round(value)} kW`;
									} else if (chart.yAxis === 'gewicht') {
										return `‚öñÔ∏è Gemiddeld gewicht: ${Math.round(value)} kg`;
									} else {
										// Voor categorische data
										if (typeof yDisplay === 'string') {
											return `üè∑Ô∏è ${chart.yAxis}: ${yDisplay}`;
										} else {
											return `üìä Gemiddelde ${chart.yAxis}: ${Math.round(value)}`;
										}
									}
								},
								
								afterLabel: function(context) {
									const xValue = context.label;
									// Vind alle producten die overeenkomen met deze X-waarde
									const matchingItems = filteredData.filter(item => item[chart.xAxis] === xValue);
									
									if (matchingItems.length === 0) return [];
									
									const details = [];
									
									// Aantal producten
									details.push(`üì¶ Aantal producten: ${matchingItems.length}`);
									details.push(''); // Lege regel voor scheiding
									
									// Verzamel alle unieke waarden voor elke kolom
									const allDetails = {};
									
									columns.forEach(column => {
										if (column === chart.xAxis) return; // Skip de X-as kolom
										
										const values = matchingItems
											.map(item => item[column])
											.filter(val => val !== null && val !== undefined && val !== '')
											.filter((value, index, self) => self.indexOf(value) === index);
										
										if (values.length > 0) {
											allDetails[column] = values;
										}
									});
									
									// Voeg alle details toe aan de tooltip
									Object.entries(allDetails).forEach(([column, values]) => {
										let emoji = 'üìã';
										
										// Specifieke emoji's
										if (column === 'merk') emoji = 'üè∑Ô∏è';
										else if (column === 'prijs') emoji = 'üí∞';
										else if (column === 'vermogen') emoji = '‚ö°';
										else if (column === 'gewicht') emoji = '‚öñÔ∏è';
										else if (column === 'energielabel') emoji = 'üåü';
										else if (column === 'geluidsniveau') emoji = 'üîä';
										else if (column === 'cop' || column === 'scop') emoji = 'üìà';
										else if (column === 'model' || column === 'naam') emoji = 'üè†';
										else if (column === 'type') emoji = 'üîß';
										
										let displayText = '';
										if (values.length === 1) {
											let value = values[0];
											
											if (column === 'prijs') {
												value = `‚Ç¨${Math.round(Number(value)).toLocaleString()}`;
											} else if (column === 'vermogen') {
												value = `${value} kW`;
											} else if (column === 'gewicht') {
												value = `${value} kg`;
											} else if (column === 'geluidsniveau') {
												value = `${value} dB`;
											}
											
											displayText = `${emoji} ${column.charAt(0).toUpperCase() + column.slice(1)}: ${value}`;
										} else if (values.length <= 5) {
											let formattedValues = values.map(value => {
												if (column === 'prijs') {
													return `‚Ç¨${Math.round(Number(value)).toLocaleString()}`;
												} else if (column === 'vermogen') {
													return `${value} kW`;
												} else if (column === 'gewicht') {
													return `${value} kg`;
												} else if (column === 'geluidsniveau') {
													return `${value} dB`;
												}
												return value;
											});
											
											displayText = `${emoji} ${column.charAt(0).toUpperCase() + column.slice(1)}: ${formattedValues.join(', ')}`;
										} else {
											if (column === 'prijs') {
												const prices = values.map(Number).filter(p => !isNaN(p));
												if (prices.length > 0) {
													const min = Math.min(...prices);
													const max = Math.max(...prices);
													displayText = `${emoji} ${column.charAt(0).toUpperCase() + column.slice(1)}: ‚Ç¨${Math.round(min)} - ‚Ç¨${Math.round(max)} (${values.length} varianten)`;
												}
											} else {
												displayText = `${emoji} ${column.charAt(0).toUpperCase() + column.slice(1)}: ${values.length} verschillende waarden`;
											}
										}
										
										if (displayText) {
											details.push(displayText);
										}
									});
									
									return details;
								},
								
								footer: function(tooltipItems) {
									const xValue = tooltipItems[0].label;
									const matchingItems = filteredData.filter(item => item[chart.xAxis] === xValue);
									
									if (matchingItems.length > 1) {
										return [``, `üí° Klik op de staaf voor gedetailleerd producten overzicht`];
									}
									
									return [];
								}
							},
							
							// Styling
							backgroundColor: 'rgba(0, 0, 0, 0.9)',
							titleColor: '#ffffff',
							titleFont: {
								size: 14,
								weight: 'bold'
							},
							bodyColor: '#ffffff',
							bodyFont: {
								size: 12
							},
							footerColor: '#cccccc',
							footerFont: {
								size: 10,
								style: 'italic'
							},
							borderColor: '#333333',
							borderWidth: 2,
							cornerRadius: 8,
							displayColors: false,
							titleMarginBottom: 10,
							bodySpacing: 4,
							footerMarginTop: 10,
							position: 'nearest',
							enabled: true,
							padding: 12
					
                        },
                        // Add data labels plugin for bar charts
                        datalabels: chart.type === 'bar' || chart.type === 'horizontalBar' ? {
                            anchor: 'end',
                            align: 'top',
                            formatter: function(value, context) {
                                // Format as currency if yAxis is prijs
                                if (chart.yAxis === 'prijs' || chart.yAxis.toLowerCase().includes('prijs')) {
                                    return '‚Ç¨' + Math.round(value);
                                }
                                return Math.round(value);
                            },
                            color: '#000',
                            font: {
                                weight: 'bold',
                                size: 12
                            }
                        } : false
                    },
                    layout: {
						padding: {
							top: chart.type === 'bar' ? 30 : (chart.type === 'scatter' ? 80 : 10), // Meer ruimte voor labels boven
							right: chart.type === 'horizontalBar' ? 80 : (chart.type === 'scatter' ? 120 : 10), // Meer ruimte voor labels rechts
							bottom: chart.type === 'scatter' ? 60 : 10, // Meer ruimte voor labels onder
							left: chart.type === 'scatter' ? 120 : 10 // Meer ruimte voor labels links
						}
					},
                    scales: getChartScales(chart, data),
                  
                    // Custom animation for charts with labels
                    animation: {
						onComplete: function() {
							console.log('üé¨ Animation complete for chart type:', chart.type);
							console.log('üé¨ Chart ID:', chart.id);
							
							if (chart.type === 'bar' || chart.type === 'horizontalBar') {
								console.log('üé¨ Calling addDataLabelsToChart');
								addDataLabelsToChart(this, chart);
							} else if (chart.type === 'scatter' || chart.type === 'bubble') {
								console.log('üé¨ Calling addScatterLabelsToChart');
								addScatterLabelsToChart(this, chart);
							}
						}
					}
                }
            };
			
			// üéØ VEILIGE ZONE START - Productnaam verkorting hier toevoegen
			if (chart && chart.type === 'horizontalBar' && data && data.labels && Array.isArray(data.labels)) {
				console.log('üîß Veilig verkorten van productnamen voor horizontale chart...');
				
				data.labels = data.labels.map(label => {
					if (label && typeof label === 'string' && label.length > 25) {
						const shortened = label.substring(0, 22) + '...';
						console.log(`üìù Verkort: "${label}" ‚Üí "${shortened}"`);
						return shortened;
					}
					return label;
				});
				
				console.log('‚úÖ Productnamen veilig verkort');
			}
				
			try {
				chartInstances[chart.id] = new Chart(ctx, chartConfig);
				
				// Custom legend toevoegen na succesvolle chart creatie
				setTimeout(() => {
					addCustomLegend(chart);
				}, 200);
				
				console.log(`‚úÖ Chart ${chart.id} successfully rendered`);
			} catch (error) {
				console.error(`‚ùå Error rendering chart ${chart.id}:`, error);
				// Toon error op canvas
				ctx.clearRect(0, 0, canvas.width, canvas.height);
				ctx.fillStyle = '#ff0000';
				ctx.font = '14px Arial';
				ctx.textAlign = 'center';
				ctx.fillText('Chart render error', canvas.width/2, canvas.height/2);
			}
		}
        
        function addScatterLabelsToChart(chartInstance, chartConfig) {
			// Only show labels if enabled for this chart
			if (!productLabelsEnabled[chartConfig.id]) {
				console.log('üö´ Labels disabled for chart:', chartConfig.id);
				return;
			}
			
			const ctx = chartInstance.ctx;
			ctx.save();
			
			// Get chart info
			const chart = charts.find(c => c.id === chartConfig.id);
			if (!chart) return;
			
			console.log('üè∑Ô∏è ========== WHITESPACE OPTIMIZED LABELS ==========');
			console.log('Filtered data count:', filteredData.length);
			console.log('Chart type:', chart.type);
			
			// Check if this is a scatter/bubble with datasets
			if (chartInstance.data.datasets && chartInstance.data.datasets.length > 0) {
				// Global tracking voor alle labels om overlap te voorkomen
				const globalUsedPositions = [];
				
				// Track all data points to avoid them
				const allDataPoints = [];
				
				// Collect all points that need labels
				const allPoints = [];
				
				// First pass: collect ALL data points for whitespace analysis
				chartInstance.data.datasets.forEach((dataset, datasetIndex) => {
					const meta = chartInstance.getDatasetMeta(datasetIndex);
					if (!meta || !meta.data || meta.hidden) return;
					
					meta.data.forEach((point) => {
						allDataPoints.push({
							x: point.x,
							y: point.y,
							radius: 8 // Standard point radius
						});
					});
				});
				
				chartInstance.data.datasets.forEach((dataset, datasetIndex) => {
					const meta = chartInstance.getDatasetMeta(datasetIndex);
					if (!meta || !meta.data || meta.hidden) return;
					
					const brand = dataset.label || 'Onbekend';
					const brandColor = brandColors[brand] || '#6B7280';
					
					// Get all data items for this brand
					const brandData = filteredData.filter(item => 
						(item.merk || item.brand || item.Brand || item.Merk || 'Onbekend') === brand
					);
					
					// Collect points for smart positioning
					meta.data.forEach((point, pointIndex) => {
						if (pointIndex >= brandData.length) return;
						
						const dataItem = brandData[pointIndex];
						if (!dataItem) return;
						
						// Enhanced product name detection
						let productName = dataItem.model || 
										dataItem.naam || 
										dataItem.name ||
										dataItem.type || 
										dataItem.productNaam || 
										dataItem['product naam'] ||
										dataItem['Product Naam'] ||
										dataItem.product_name ||
										dataItem.productname ||
										dataItem.description ||
										dataItem.omschrijving ||
										dataItem.titel ||
										dataItem.title ||
										'Product';
						
						// Search for any field containing name/naam/model if none of the above worked
						if (productName === 'Product') {
							const nameField = Object.keys(dataItem).find(key => 
								(key.toLowerCase().includes('naam') || 
								 key.toLowerCase().includes('name') || 
								 key.toLowerCase().includes('model') ||
								 key.toLowerCase().includes('product') ||
								 key.toLowerCase().includes('type')) &&
								dataItem[key] && 
								typeof dataItem[key] === 'string' && 
								dataItem[key].trim().length > 2
							);
							
							if (nameField) {
								productName = dataItem[nameField];
							} else {
								// Last resort: use first string field that's not ID/URL
								const fallbackValue = Object.values(dataItem).find(value => 
									typeof value === 'string' && 
									value.length > 3 && 
									!value.match(/^https?:\/\//) && 
									!value.match(/^\d+$/) && 
									value !== dataItem.merk
								);
								
								if (fallbackValue) {
									productName = fallbackValue;
								} else {
									productName = `${dataItem.merk || 'Onbekend'} Product`;
								}
							}
						}
						
						productName = productName.toString().replace(/<[^>]*>/g, '').trim();
						if (productName.length > 35) {
							productName = productName.substring(0, 32) + '...';
						}
						
						console.log(`üîç Product: ${productName} at (${Math.round(point.x)}, ${Math.round(point.y)})`);
						
						allPoints.push({
							x: point.x,
							y: point.y,
							productName: productName,
							brand: brand,
							brandColor: brandColor,
							datasetIndex: datasetIndex,
							pointIndex: pointIndex,
							globalIndex: allPoints.length
						});
					});
				});
				
				if (allPoints.length === 0) {
					console.log('‚ö†Ô∏è No points found for labeling');
					return;
				}
				
				console.log(`üéØ Applying whitespace-optimized positioning to ${allPoints.length} labels...`);
				
				// Function to check if an area is empty (whitespace)
				function isAreaEmpty(x, y, width, height, excludePoint) {
					// Check against all data points
					for (let i = 0; i < allDataPoints.length; i++) {
						const point = allDataPoints[i];
						if (excludePoint && point.x === excludePoint.x && point.y === excludePoint.y) continue;
						
						// Check if data point overlaps with label area (with safety margin)
						if (point.x + point.radius + 30 > x && point.x - point.radius - 30 < x + width &&
							point.y + point.radius + 30 > y && point.y - point.radius - 30 < y + height) {
							return false;
						}
					}
					
					// Check against existing labels
					for (let j = 0; j < globalUsedPositions.length; j++) {
						const usedPos = globalUsedPositions[j];
						if (!(x + width + 15 < usedPos.x || x - 15 > usedPos.x + usedPos.width ||
							  y + height + 15 < usedPos.y || y - 15 > usedPos.y + usedPos.height)) {
							return false;
						}
					}
					
					return true;
				}
				
				// Process each point with whitespace-optimized positioning
				allPoints.forEach((point, globalIndex) => {
					// WHITESPACE-OPTIMIZED POSITIONING ALGORITHM
					const baseX = point.x;
					const baseY = point.y;
					
					// Get canvas bounds with padding
					const canvasWidth = chartInstance.canvas.width;
					const canvasHeight = chartInstance.canvas.height;
					const padding = 40; // Increased padding for better whitespace usage
					const labelWidth = Math.max(140, ctx.measureText(point.productName).width + 25);
					const labelHeight = 24;
					
					console.log(`üìê Finding whitespace for ${point.productName} near (${Math.round(baseX)}, ${Math.round(baseY)})`);
					
					// Generate positions that prioritize whitespace areas
					const whitespacePositions = [];
					
					// Scan for whitespace in expanding circles around the point
					const maxDistance = 150; // Maximum distance to search for whitespace
					const stepSize = 25; // Step size for scanning
					
					for (let distance = 50; distance <= maxDistance; distance += stepSize) {
						// Check 8 directions around the point at this distance
						const directions = [
							{ angle: 0, desc: 'right' },       // Right
							{ angle: Math.PI, desc: 'left' },  // Left  
							{ angle: -Math.PI/2, desc: 'top' }, // Top
							{ angle: Math.PI/2, desc: 'bottom' }, // Bottom
							{ angle: -Math.PI/4, desc: 'top-right' }, // Top-right
							{ angle: Math.PI/4, desc: 'bottom-right' }, // Bottom-right
							{ angle: -3*Math.PI/4, desc: 'top-left' }, // Top-left
							{ angle: 3*Math.PI/4, desc: 'bottom-left' }  // Bottom-left
						];
						
						for (let d = 0; d < directions.length; d++) {
							const dir = directions[d];
							const testX = baseX + Math.cos(dir.angle) * distance - labelWidth/2;
							const testY = baseY + Math.sin(dir.angle) * distance - labelHeight/2;
							
							// Check canvas bounds
							if (testX < padding || testX + labelWidth > canvasWidth - padding ||
								testY < padding || testY + labelHeight > canvasHeight - padding) {
								continue;
							}
							
							// Check if this area is empty (whitespace)
							if (isAreaEmpty(testX, testY, labelWidth, labelHeight, point)) {
								whitespacePositions.push({
									x: testX,
									y: testY,
									distance: distance,
									direction: dir.desc,
									score: 1000 - distance // Higher score for closer positions
								});
								console.log(`‚úÖ Found whitespace at distance ${distance}px (${dir.desc})`);
							}
						}
						
						// If we found good positions, stop searching further
						if (whitespacePositions.length >= 3) break;
					}
					
					let labelX, labelY;
					let positionFound = false;
					
					if (whitespacePositions.length > 0) {
						// Sort by score (closer positions preferred)
						whitespacePositions.sort((a, b) => b.score - a.score);
						
						// Use the best whitespace position
						const bestPosition = whitespacePositions[0];
						labelX = bestPosition.x;
						labelY = bestPosition.y;
						positionFound = true;
						
						console.log(`üéØ Using whitespace position: ${bestPosition.direction} at distance ${bestPosition.distance}px`);
					}
					
					// Fallback to original algorithm if no whitespace found
					if (!positionFound) {
						console.log(`‚ö†Ô∏è No whitespace found for ${point.productName}, using fallback positioning`);
						
						// Fallback positions with increased distances
						const fallbackPositions = [
							{ x: 60, y: -30 },
							{ x: -labelWidth - 60, y: -30 },
							{ x: -labelWidth/2, y: -80 },
							{ x: -labelWidth/2, y: 80 },
							{ x: 80, y: 50 },
							{ x: -labelWidth - 80, y: 50 }
						];
						
						for (let p = 0; p < fallbackPositions.length; p++) {
							const pos = fallbackPositions[p];
							const testX = baseX + pos.x;
							const testY = baseY + pos.y;
							
							if (testX > padding && testX + labelWidth < canvasWidth - padding &&
								testY > padding && testY + labelHeight < canvasHeight - padding) {
								labelX = testX;
								labelY = testY;
								positionFound = true;
								break;
							}
						}
					}
					
					// Final fallback
					if (!positionFound) {
						labelX = Math.max(padding, Math.min(baseX + 60, canvasWidth - labelWidth - padding));
						labelY = Math.max(padding, Math.min(baseY - 30, canvasHeight - labelHeight - padding));
					}
					
					// Register this position as used
					globalUsedPositions.push({ 
						x: labelX, 
						y: labelY, 
						width: labelWidth, 
						height: labelHeight 
					});
					
					// Calculate line end point (edge of label box closest to point)
					let lineToX, lineToY;
					
					// Find closest edge of label to the data point
					if (baseX < labelX) {
						lineToX = labelX; // Left edge
						lineToY = Math.max(labelY, Math.min(baseY, labelY + labelHeight));
					} else if (baseX > labelX + labelWidth) {
						lineToX = labelX + labelWidth; // Right edge
						lineToY = Math.max(labelY, Math.min(baseY, labelY + labelHeight));
					} else {
						lineToX = Math.max(labelX, Math.min(baseX, labelX + labelWidth));
						if (baseY < labelY) {
							lineToY = labelY; // Top edge
						} else {
							lineToY = labelY + labelHeight; // Bottom edge
						}
					}
					
					// Draw connector line (subtle and curved)
					ctx.strokeStyle = point.brandColor + '80'; // Semi-transparent
					ctx.lineWidth = 1;
					ctx.setLineDash([2, 3]);
					ctx.beginPath();
					ctx.moveTo(baseX, baseY);
					
					// Add curve to the line for better aesthetics
					const midX = (baseX + lineToX) / 2;
					const midY = (baseY + lineToY) / 2;
					const distance = Math.sqrt(Math.pow(baseX - lineToX, 2) + Math.pow(baseY - lineToY, 2));
					const curveOffset = Math.min(20, distance * 0.2);
					
					ctx.quadraticCurveTo(midX + curveOffset, midY - curveOffset, lineToX, lineToY);
					ctx.stroke();
					ctx.setLineDash([]);
					
					// Draw small arrowhead
					ctx.fillStyle = point.brandColor + '80';
					ctx.beginPath();
					const angle = Math.atan2(lineToY - baseY, lineToX - baseX);
					const arrowSize = 4;
					ctx.moveTo(lineToX, lineToY);
					ctx.lineTo(
						lineToX - arrowSize * Math.cos(angle - Math.PI/6),
						lineToY - arrowSize * Math.sin(angle - Math.PI/6)
					);
					ctx.lineTo(
						lineToX - arrowSize * Math.cos(angle + Math.PI/6),
						lineToY - arrowSize * Math.sin(angle + Math.PI/6)
					);
					ctx.closePath();
					ctx.fill();
					
					// Draw label background
					ctx.font = 'bold 11px Arial';
					const padding2 = 8;
					
					// Background with brand color and subtle gradient
					const gradient = ctx.createLinearGradient(labelX, labelY, labelX, labelY + labelHeight);
					gradient.addColorStop(0, point.brandColor + '15');
					gradient.addColorStop(1, point.brandColor + '08');
					ctx.fillStyle = gradient;
					ctx.fillRect(labelX, labelY, labelWidth, labelHeight);
					
					// Subtle border
					ctx.strokeStyle = point.brandColor + '60';
					ctx.lineWidth = 1.5;
					ctx.strokeRect(labelX, labelY, labelWidth, labelHeight);
					
					// Text
					ctx.fillStyle = '#000';
					ctx.textAlign = 'left';
					ctx.textBaseline = 'middle';
					ctx.fillText(point.productName, labelX + padding2, labelY + labelHeight/2);
					
					console.log(`üè∑Ô∏è Whitespace-optimized label: ${point.productName} at (${Math.round(labelX)}, ${Math.round(labelY)})`);
				});
				
				console.log('üéØ Whitespace-optimized positioning complete!');
				
			} else {
				console.log(`üè∑Ô∏è No datasets found for labeling`);
			}
			
			ctx.restore();
		}
        
        // Function to manually add data labels to bar charts
        function addDataLabelsToChart(chartInstance, chartConfig) {
            const ctx = chartInstance.ctx;
            const meta = chartInstance.getDatasetMeta(0);
            
            if (!meta || !meta.data) return;
            
            ctx.save();
            ctx.font = 'bold 12px Arial';
            ctx.fillStyle = '#000';
            
            meta.data.forEach((bar, index) => {
                const value = chartInstance.data.datasets[0].data[index];
                let displayValue;
                
                // Format value based on chart type
                if (chartConfig.yAxis === 'prijs' || chartConfig.yAxis.toLowerCase().includes('prijs')) {
                    displayValue = '‚Ç¨' + Math.round(value);
                } else {
                    displayValue = Math.round(value);
                }
                
                if (chartConfig.type === 'horizontalBar') {
                    // Horizontal bar - label to the right of the bar
                    ctx.textAlign = 'left';
                    ctx.textBaseline = 'middle';
                    ctx.fillStyle = '#000';
                    // Add some padding from the bar end
                    ctx.fillText(displayValue, bar.x + 8, bar.y);
                } else {
                    // Vertical bar - label on top of the bar
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'bottom';
                    ctx.fillStyle = '#000';
                    // Add some padding above the bar
                    ctx.fillText(displayValue, bar.x, bar.y - 8);
                }
            });
            
            ctx.restore();
        }
        
		
        function prepareChartData(chart) {
			if (!brandColors || Object.keys(brandColors).length === 0) {
				generateBrandColors();
			}
			
			const brands = [...new Set(filteredData.map(item => 
				item.merk || item.brand || item.Brand || item.Merk || 'Onbekend'
			).filter(Boolean))];
			
			// Detecteer data types voor assen
			const xIsNumeric = isNumericColumn(chart.xAxis);
			const yIsNumeric = isNumericColumn(chart.yAxis);
			
			console.log(`üìä Chart ${chart.id}: X(${chart.xAxis})=${xIsNumeric?'numeric':'categorical'}, Y(${chart.yAxis})=${yIsNumeric?'numeric':'categorical'}`);
			
			// Auto-detect beste chart type gebaseerd op data types
			if (chart.type === 'scatter' || chart.type === 'categoricalScatter') {
				if (!xIsNumeric || !yIsNumeric) {
					// E√©n of beide assen categorisch ‚Üí gebruik categorische scatter
					return prepareCategoricalScatterData(chart, brands, xIsNumeric, yIsNumeric);
				} else {
					// Beide numeriek ‚Üí normale scatter
					return prepareNumericScatterData(chart, brands);
				}
			}

			if (chart.type === 'bubble') {
				if (!xIsNumeric || !yIsNumeric) {
					// Categorische bubble chart ‚Üí gebruik aangepaste implementatie
					const scatterData = prepareCategoricalScatterData(chart, brands, xIsNumeric, yIsNumeric);
					
					// Voeg bubble sizes toe
					if (chart.sizeBy && scatterData.datasets) {
						scatterData.datasets.forEach(dataset => {
							dataset.data = dataset.data.map(point => {
								// Vind originele data item voor deze punt
								const originalItem = filteredData.find(item => 
									item[chart.xAxis] === point.originalX && 
									item[chart.yAxis] === point.originalY
								);
								
								if (originalItem && chart.sizeBy) {
									const sizeVal = Number(originalItem[chart.sizeBy]);
									point.r = isNaN(sizeVal) ? 8 : Math.max(5, Math.min(30, Math.sqrt(sizeVal) * 1.5));
								} else {
									point.r = 8;
								}
								
								return point;
							});
						});
					}
					
					return scatterData;
				} else {
					// Beide numeriek ‚Üí normale bubble
					return prepareNumericScatterData(chart, brands);
				}
			}

			switch(chart.type) {
				case 'horizontalCategorical':
					return prepareHorizontalCategoricalData(chart, brands, xIsNumeric, yIsNumeric);
				
				case 'heatmap':
					return prepareHeatmapData(chart, brands);
				
				case 'bar':
				case 'horizontalBar':
				default:
					return prepareBarData(chart, brands);
			}
		}
		
		// NIEUWE FUNCTIES TOEVOEGEN:

		function prepareCategoricalScatterData(chart, brands, xIsNumeric, yIsNumeric) {
			console.log(`üéØ CategoricalScatter: X=${chart.xAxis} (${xIsNumeric ? 'NUM' : 'CAT'}), Y=${chart.yAxis} (${yIsNumeric ? 'NUM' : 'CAT'})`);
			
			// Beide numeriek ‚Üí gebruik normale scatter
			if (xIsNumeric && yIsNumeric) {
				return prepareNumericScatterData(chart, brands);
			}
			
			// Beide categorisch ‚Üí gebruik heatmap approach
			if (!xIsNumeric && !yIsNumeric) {
				return prepareHeatmapData(chart, brands);
			}
			
			// X categorisch, Y numeriek
			if (!xIsNumeric && yIsNumeric) {
				const xCategories = [...new Set(filteredData.map(item => item[chart.xAxis]).filter(Boolean))].sort();
				console.log(`üè∑Ô∏è X-categories: ${xCategories.join(', ')}`);
				
				const datasets = brands.map(brand => {
					const brandData = filteredData.filter(item => 
						(item.merk || item.brand || item.Brand || item.Merk || 'Onbekend') === brand
					);
					
					const data = brandData.map(item => {
						const xVal = item[chart.xAxis];
						const yVal = Number(item[chart.yAxis]);
						const xIndex = xCategories.indexOf(xVal);
						
						if (xIndex >= 0 && !isNaN(yVal)) {
							return {
								x: xVal,  // ‚úÖ Gebruik INDEX voor Chart.js positioning
								y: yVal,    // ‚úÖ Numerieke waarde blijft hetzelfde
								originalX: xVal,
								originalY: yVal,
								categoryLabel: xVal  // Voor tooltips
							};
						}
						return null;
					}).filter(Boolean);
					
					console.log(`üìä ${brand}: ${data.length} datapunten`);
					
					return {
						label: brand,
						data: data,
						backgroundColor: brandColors[brand] || '#6B7280',
						borderColor: brandColors[brand] || '#6B7280',
						pointRadius: 6,
						pointHoverRadius: 10,
						pointBorderWidth: 2,
						pointBorderColor: '#ffffff'
					};
				}).filter(dataset => dataset.data.length > 0);
				
				return { 
					datasets,
					xCategoryLabels: xCategories
				};
			}
			
			// X numeriek, Y categorisch
			else {
				const yCategories = [...new Set(filteredData.map(item => item[chart.yAxis]).filter(Boolean))].sort();
				console.log(`üè∑Ô∏è Y-categories: ${yCategories.join(', ')}`);
				
				const datasets = brands.map(brand => {
					const brandData = filteredData.filter(item => 
						(item.merk || item.brand || item.Brand || item.Merk || 'Onbekend') === brand
					);
					
					const data = brandData.map(item => {
						const xVal = Number(item[chart.xAxis]);
						const yVal = item[chart.yAxis];
						const yIndex = yCategories.indexOf(yVal);
						
						if (!isNaN(xVal) && yIndex >= 0) {
							return {
								x: xVal,    // ‚úÖ Numerieke waarde blijft hetzelfde
								y: yVal,  // ‚úÖ Gebruik INDEX voor Chart.js positioning
								originalX: xVal,
								originalY: yVal,
								categoryLabel: yVal  // Voor tooltips
							};
						}
						return null;
					}).filter(Boolean);
					
					console.log(`üìä ${brand}: ${data.length} datapunten`);
					
					return {
						label: brand,
						data: data,
						backgroundColor: brandColors[brand] || '#6B7280',
						borderColor: brandColors[brand] || '#6B7280',
						pointRadius: 6,
						pointHoverRadius: 10,
						pointBorderWidth: 2,
						pointBorderColor: '#ffffff'
					};
				}).filter(dataset => dataset.data.length > 0);
				
				return { 
					datasets,
					yCategoryLabels: yCategories
				};
			}
		}

		function prepareHorizontalCategoricalData(chart, brands, xIsNumeric, yIsNumeric) {
			// X-as numeriek, Y-as categorisch
			const categories = [...new Set(filteredData.map(item => item[chart.yAxis]).filter(Boolean))];
			
			const datasets = brands.map(brand => {
				const brandData = filteredData.filter(item => 
					(item.merk || item.brand || item.Brand || item.Merk || 'Onbekend') === brand
				);
				
				const data = brandData.map(item => {
					const xVal = Number(item[chart.xAxis]);
					const yVal = item[chart.yAxis];
					const yIndex = categories.indexOf(yVal);
					
					return {
						x: isNaN(xVal) ? 0 : xVal,
						y: yIndex >= 0 ? yIndex : 0,
						originalY: yVal // Voor tooltips
					};
				}).filter(point => point.x !== 0);
				
				return {
					label: brand,
					data: data,
					backgroundColor: brandColors[brand] || '#6B7280',
					borderColor: brandColors[brand] || '#6B7280',
					pointRadius: 8,
					pointHoverRadius: 12
				};
			}).filter(dataset => dataset.data.length > 0);
			
			return { 
				datasets,
				categoryLabels: categories
			};
		}

		function prepareHeatmapData(chart, brands) {
			// Beide assen categorisch - maak een heatmap
			const xCategories = [...new Set(filteredData.map(item => item[chart.xAxis]).filter(Boolean))];
			const yCategories = [...new Set(filteredData.map(item => item[chart.yAxis]).filter(Boolean))];
			
			// Maak een matrix van counts
			const matrix = {};
			yCategories.forEach(ycat => {
				matrix[ycat] = {};
				xCategories.forEach(xcat => {
					matrix[ycat][xcat] = 0;
				});
			});
			
			// Tel voorkomens
			filteredData.forEach(item => {
				const xVal = item[chart.xAxis];
				const yVal = item[chart.yAxis];
				if (xVal && yVal && matrix[yVal] && matrix[yVal][xVal] !== undefined) {
					matrix[yVal][xVal]++;
				}
			});
			
			// Converteer naar Chart.js bubble formaat
			const data = [];
			const maxCount = Math.max(...Object.values(matrix).flatMap(row => Object.values(row)));
			
			yCategories.forEach((ycat, yIndex) => {
				xCategories.forEach((xcat, xIndex) => {
					const count = matrix[ycat][xcat];
					if (count > 0) {
						data.push({
							x: xcat,  // ‚úÖ OPLOSSING: Gebruik originele labels
							y: ycat,  // ‚úÖ OPLOSSING: Gebruik originele labels
							r: Math.max(5, (count / maxCount) * 30),
							count: count,
							xLabel: xcat,
							yLabel: ycat
						});
					}
				});
			});
			
			return {
				datasets: [{
					label: 'Heatmap',
					data: data,
					backgroundColor: data.map(point => {
						const intensity = point.count / maxCount;
						return `rgba(59, 130, 246, ${0.3 + intensity * 0.7})`;
					}),
					borderColor: '#3B82F6',
					borderWidth: 1
				}],
				xCategoryLabels: xCategories,
				yCategoryLabels: yCategories
			};
		}

		function prepareNumericScatterData(chart, brands) {
			// Bestaande implementatie voor numerieke scatter plots
			const datasets = brands.map(brand => {
				const brandData = filteredData.filter(item => 
					(item.merk || item.brand || item.Brand || item.Merk || 'Onbekend') === brand
				);
				
				const data = brandData.map(item => {
					const xVal = Number(item[chart.xAxis]);
					const yVal = Number(item[chart.yAxis]);
					
					let result = {
						x: isNaN(xVal) ? 0 : xVal,
						y: isNaN(yVal) ? 0 : yVal
					};
					
					// Voor bubble charts
					if (chart.type === 'bubble' && chart.sizeBy) {
						const sizeVal = Number(item[chart.sizeBy]);
						result.r = isNaN(sizeVal) ? 5 : Math.max(5, Math.min(50, Math.sqrt(sizeVal) * 2));
					}
					
					return result;
				}).filter(point => point.x !== 0 || point.y !== 0);
				
				return {
					label: brand,
					data: data,
					backgroundColor: chart.type === 'bubble' ? 
						(brandColors[brand] || '#6B7280') + '80' : 
						brandColors[brand] || '#6B7280',
					borderColor: brandColors[brand] || '#6B7280',
					pointRadius: chart.type === 'bubble' ? undefined : 8,
					pointHoverRadius: chart.type === 'bubble' ? undefined : 12,
					borderWidth: 2
				};
			}).filter(dataset => dataset.data.length > 0);
			
			return { datasets };
		}

		function prepareBarData(chart, brands) {
			console.log(`üìä PrepareBarData: X=${chart.xAxis} (${isNumericColumn(chart.xAxis) ? 'NUM' : 'CAT'}), Y=${chart.yAxis} (${isNumericColumn(chart.yAxis) ? 'NUM' : 'CAT'})`);
			
			const xIsNumeric = isNumericColumn(chart.xAxis);
			const yIsNumeric = isNumericColumn(chart.yAxis);
			
			// Voor categorische Y-as: tel het aantal items per X-waarde
			if (!yIsNumeric) {
				console.log(`üî¢ Y-as is categorisch (${chart.yAxis}), tel aantal items per X-waarde`);
				
				const counts = {};
				const labelToMerkMap = {};
				
				filteredData.forEach(item => {
					const xValue = item[chart.xAxis];
					if (xValue) {
						if (!counts[xValue]) {
							counts[xValue] = 0;
							labelToMerkMap[xValue] = item.merk || item.brand || item.Brand || item.Merk || 'Onbekend';
						}
						counts[xValue]++;
					}
				});
				
				const chartData = Object.entries(counts).map(([label, count]) => {
					const associatedMerk = labelToMerkMap[label];
					const color = brandColors[associatedMerk] || brandColors[label] || '#3B82F6';
					
					return {
						label: label,
						value: count,
						color: color
					};
				}).sort((a, b) => b.value - a.value);
				
				const labels = chartData.map(item => item.label);
				const values = chartData.map(item => item.value);
				const colors = chartData.map(item => item.color);
				
				return {
					labels: labels,
					datasets: [{
						label: `Aantal ${chart.yAxis}`,
						data: values,
						backgroundColor: colors.map(color => color + 'CC'),
						borderColor: colors,
						borderWidth: 2
					}]
				};
			}
			
			// Voor numerieke Y-as: bereken gemiddelde zoals voorheen
			else {
				console.log(`üìä Y-as is numeriek (${chart.yAxis}), bereken gemiddelde per X-waarde`);
				
				const aggregatedData = {};
				const labelToMerkMap = {};
				
				filteredData.forEach(item => {
					const key = item[chart.xAxis];
					if (!aggregatedData[key]) {
						aggregatedData[key] = [];
						labelToMerkMap[key] = item.merk || item.brand || item.Brand || item.Merk || 'Onbekend';
					}
					
					const yValue = Number(item[chart.yAxis]);
					if (!isNaN(yValue)) {
						aggregatedData[key].push(yValue);
					}
				});
				
				const chartData = Object.entries(aggregatedData).map(([label, values]) => {
					const associatedMerk = labelToMerkMap[label];
					const color = brandColors[associatedMerk] || brandColors[label] || '#3B82F6';
					
					return {
						label: label,
						value: values.length > 0 ? values.reduce((sum, val) => sum + val, 0) / values.length : 0,
						color: color
					};
				}).sort((a, b) => b.value - a.value);
				
				const labels = chartData.map(item => item.label);
				const values = chartData.map(item => item.value);
				const colors = chartData.map(item => item.color);
				
				return {
					labels: labels,
					datasets: [{
						label: `Gemiddelde ${chart.yAxis}`,
						data: values,
						backgroundColor: colors.map(color => color + 'CC'),
						borderColor: colors,
						borderWidth: 2
					}]
				};
			}
		}
				
		function getChartScales(chart, data) {
			// üõ°Ô∏è VEILIGHEIDSCONTROLES
			console.log('üîç getChartScales aangeroepen:', { 
				chartId: chart.id, 
				xAxis: chart.xAxis, 
				yAxis: chart.yAxis,
				hasColumns: Array.isArray(columns),
				columnsLength: columns ? columns.length : 0
			});
			
			// Als geen columns of axes, gebruik standaard scales
			if (!columns || columns.length === 0 || !chart.xAxis || !chart.yAxis) {
				console.log('‚ö†Ô∏è Geen columns/axes beschikbaar, gebruik standaard scales');
				return {
					x: {
						display: true,
						title: {
							display: true,
							text: chart.xAxis || 'X-as'
						}
					},
					y: {
						display: true,
						title: {
							display: true,
							text: chart.yAxis || 'Y-as'
						}
					}
				};
			}
			
			// Probeer numeriek status te bepalen (met error handling)
			let xIsNumeric = false;
			let yIsNumeric = false;
			
			try {
				xIsNumeric = isNumericColumn(chart.xAxis);
				yIsNumeric = isNumericColumn(chart.yAxis);
				console.log('üìä Column types bepaald:', { xIsNumeric, yIsNumeric });
			} catch (error) {
				console.warn('‚ö†Ô∏è Fout bij bepalen column types, gebruik standaard:', error);
				// Fallback naar standaard gedrag
				return {
					x: {
						display: true,
						title: {
							display: true,
							text: chart.xAxis
						}
					},
					y: {
						display: true,
						title: {
							display: true,
							text: chart.yAxis
						}
					}
				};
			}
			
			// Start met standaard scales
			let scales = {
				x: {
					display: true,
					title: {
						display: true,
						text: chart.xAxis
					}
				},
				y: {
					display: true,
					title: {
						display: true,
						text: chart.yAxis
					}
				}
			};
			
			// Alleen categorische aanpassingen als data beschikbaar is
			if (data && typeof data === 'object') {
				// Categorische X-as (voor scatter/bubble charts)
				// ‚úÖ OPLOSSING: Voor categorische assen, gebruik standaard Chart.js categorische schaling
				// Categorische X-as
				if (!xIsNumeric && (data.categoryLabels || data.xCategoryLabels)) {
					console.log('üè∑Ô∏è Configureren categorische X-as');
					scales.x.type = 'category';
					scales.x.labels = data.categoryLabels || data.xCategoryLabels;
				}

				// Categorische Y-as  
				if (!yIsNumeric && (data.categoryLabels || data.yCategoryLabels)) {
					console.log('üè∑Ô∏è Configureren categorische Y-as');
					scales.y.type = 'category';
					scales.y.labels = data.categoryLabels || data.yCategoryLabels;
				}
			}
			
			console.log('‚úÖ Scales geconfigureerd:', scales);
			return scales;
		}
				
        function addCustomLegend(chart) {
			const legendContainer = document.getElementById(`legend-${chart.id}`);
			
			if (!legendContainer) {
				console.warn(`Legend container niet gevonden voor chart ${chart.id}`);
				return;
			}
			
			// Clear existing legend
			legendContainer.innerHTML = '';
			
			// Get unique brands from filtered data
			const brands = [...new Set(filteredData.map(item => 
				item.merk || item.brand || item.Brand || item.Merk || 'Onbekend'
			).filter(Boolean))];
			
			if (brands.length === 0) {
				console.warn(`Geen brands gevonden voor chart ${chart.id}`);
				return;
			}
			
			console.log(`üè∑Ô∏è Creating legend for chart ${chart.id} with brands:`, brands);
			
			// Create legend items
			brands.forEach(brand => {
				const legendItem = document.createElement('div');
				legendItem.className = 'chart-legend-item';
				legendItem.dataset.brand = brand;
				legendItem.dataset.chartId = chart.id;
				
				const dot = document.createElement('div');
				dot.className = 'chart-legend-dot';
				dot.style.backgroundColor = brandColors[brand] || '#6B7280';
				
				const label = document.createElement('span');
				label.textContent = brand;
				
				legendItem.appendChild(dot);
				legendItem.appendChild(label);
				
				// Add click handler to toggle brand visibility
				legendItem.addEventListener('click', () => toggleBrandVisibility(chart.id, brand, legendItem));
				
				legendContainer.appendChild(legendItem);
			});
		}
        
        function toggleBrandVisibility(chartId, brand, legendItem) {
            const chartInstance = chartInstances[chartId];
            if (!chartInstance) return;
            
            // Find dataset index for this brand
            let datasetIndex = -1;
            chartInstance.data.datasets.forEach((dataset, index) => {
                if (dataset.label === brand) {
                    datasetIndex = index;
                }
            });
            
            if (datasetIndex !== -1) {
                const meta = chartInstance.getDatasetMeta(datasetIndex);
                meta.hidden = meta.hidden === null ? true : !meta.hidden;
                
                // Update legend item appearance
                if (meta.hidden) {
                    legendItem.classList.add('hidden');
                } else {
                    legendItem.classList.remove('hidden');
                }
                
                chartInstance.update();
            }
        }
        
        function updateCharts() {
            charts.forEach(chart => {
                if (chart.xAxis && chart.yAxis) {
                    renderChart(chart);
                }
            });
            updateColorLegend();
        }
        
        function toggleEditMode() {
            editMode = !editMode;
            document.getElementById('editModeText').textContent = editMode ? 'üíæ Opslaan' : '‚öôÔ∏è Configureer';
            document.body.classList.toggle('edit-mode', editMode);
            renderChartsGrid();
        }
        
        function addChart() {
            const newId = Date.now().toString();
            charts.push({
                id: newId,
                type: 'scatter',
                xAxis: columns[0] || '',
                yAxis: columns[1] || ''
            });
            renderChartsGrid();
        }
        
        function removeChart(chartId) {
            charts = charts.filter(chart => chart.id !== chartId);
            if (chartInstances[chartId]) {
                chartInstances[chartId].destroy();
                delete chartInstances[chartId];
            }
            renderChartsGrid();
        }
		
		function toggleProductLabels(chartId) {
			console.log('üîÑ toggleProductLabels called for:', chartId);
			
			const button = document.getElementById(`labelToggle-${chartId}`);
			const chart = charts.find(c => c.id === chartId);
			
			console.log('üîÑ Button found:', !!button);
			console.log('üîÑ Chart found:', !!chart);
			
			if (!chart || !button) return;
			
			// Toggle state
			productLabelsEnabled[chartId] = !productLabelsEnabled[chartId];
			
			console.log('üîÑ New state:', productLabelsEnabled[chartId]);
			console.log('üîÑ All states:', productLabelsEnabled);
			
			// Update button appearance
			if (productLabelsEnabled[chartId]) {
				button.textContent = 'üö´ Verberg Labels';
				button.style.background = '#E31E24';
				button.style.borderColor = '#E31E24';
			} else {
				button.textContent = 'üè∑Ô∏è Toon Labels';
				button.style.background = '#666';
				button.style.borderColor = '#666';
			}
			
			console.log('üîÑ About to re-render chart...');
			// Re-render chart to apply/remove labels
			renderChart(chart);
		}
				
        function exportToCSV() {
            if (filteredData.length === 0) {
                alert('Geen data om te exporteren');
                return;
            }
            
            const csv = Papa.unparse(filteredData);
            const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = `warmtepomp-data-${new Date().toISOString().split('T')[0]}.csv`;
            link.click();
        }
        
        function exportToJSON() {
            if (filteredData.length === 0) {
                alert('Geen data om te exporteren');
                return;
            }
            
            const json = JSON.stringify(filteredData, null, 2);
            const blob = new Blob([json], { type: 'application/json;charset=utf-8;' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = `warmtepomp-data-${new Date().toISOString().split('T')[0]}.json`;
            link.click();
        }
        
        /**
         * Product Selection Functions
         */
        function toggleProductSelectionMode() {
            productSelectionMode = !productSelectionMode;
            
            if (!productSelectionMode) {
                // Als we selectie mode uitschakelen, wis dan selecties
                selectedProducts.clear();
            }
            
            updateProductsOverview();
        }
        
        function toggleProductSelection(productId) {
            if (!productSelectionMode) return;
            
            if (selectedProducts.has(productId)) {
                selectedProducts.delete(productId);
            } else {
                selectedProducts.add(productId);
            }
            
            updateProductsOverview();
        }
        
        function selectAllVisibleProducts() {
            filteredData.forEach((product, index) => {
                const productName = (() => {
                    // Eerst proberen de meest waarschijnlijke velden
                    const directFields = [
                        product.model, 
                        product.naam, 
                        product.name,
                        product.title,
                        product.productNaam, 
                        product['product naam'],
                        product.product_name,
                        product.productname,
                        product.description,
                        product.omschrijving,
                        product.type
                    ].find(field => field && typeof field === 'string' && field.trim().length > 0);
                    
                    if (directFields) return directFields.trim();
                    
                    // Als directe velden niet werken, zoek naar elk veld dat 'naam', 'name', 'title', 'model' bevat
                    const nameFields = Object.keys(product).filter(key => 
                        (key.toLowerCase().includes('naam') || 
                         key.toLowerCase().includes('name') || 
                         key.toLowerCase().includes('title') || 
                         key.toLowerCase().includes('model') ||
                         key.toLowerCase().includes('product')) &&
                        product[key] && 
                        typeof product[key] === 'string' && 
                        product[key].trim().length > 2
                    );
                    
                    if (nameFields.length > 0) {
                        return product[nameFields[0]].trim();
                    }
                    
                    // Als laatste redmiddel, neem het eerste niet-lege string veld dat geen URL/ID is
                    const fallbackField = Object.entries(product).find(([key, value]) => 
                        typeof value === 'string' && 
                        value.length > 3 && 
                        !key.toLowerCase().includes('url') &&
                        !key.toLowerCase().includes('id') &&
                        !key.toLowerCase().includes('link') &&
                        !value.match(/^https?:\/\//) && // Geen URLs
                        !value.match(/^\d+$/) && // Geen pure nummers
                        value !== product.merk // Niet hetzelfde als merk
                    );
                    
                    return fallbackField ? fallbackField[1].trim() : 'Warmtepomp Product';
                })();
                const productId = `product_${index}_${productName.replace(/[^a-zA-Z0-9]/g, '_')}`;
                selectedProducts.add(productId);
            });
            
            updateProductsOverview();
        }
        
        function clearProductSelection() {
            selectedProducts.clear();
            updateProductsOverview();
        }
        
        function applyProductSelection() {
            if (selectedProducts.size === 0) {
                alert('‚ö†Ô∏è Selecteer eerst een of meer producten om te filteren!');
                return;
            }
            
            // Converteer product IDs terug naar data indexen
            const selectedIndexes = [];
            selectedProducts.forEach(productId => {
                const indexMatch = productId.match(/^product_([\d]+)_/);
                if (indexMatch) {
                    selectedIndexes.push(parseInt(indexMatch[1]));
                }
            });
            
            // Filter de data naar alleen geselecteerde producten
            const originalFilteredData = [...filteredData];
            filteredData = originalFilteredData.filter((product, index) => {
                return selectedIndexes.includes(index);
            });
            
            console.log(`üìä Diagrammen gefilterd naar ${filteredData.length} geselecteerde producten`);
            
            // Update alles
            updateStatistics();
            updateColorLegend();
            updateAllCharts();
            
            // Sluit het producten overzicht
            hideProductsOverview();
            
            // Scroll naar de diagrammen
            document.getElementById('chartsSection').scrollIntoView({ behavior: 'smooth' });
            
            // Toon bevestiging
            setTimeout(() => {
                alert(`‚úÖ Diagrammen tonen nu alleen de ${selectedProducts.size} geselecteerde producten!`);
            }, 500);
        }
        
        // Herstel originele filter functie
        function resetToOriginalFilter() {
            // Herstel naar de originele gefilterde data (voor product selectie)
            applyFilters(); // Dit zal de filters opnieuw toepassen zonder product selectie
            
            // Wis product selectie
            selectedProducts.clear();
            productSelectionMode = false;
            
            updateProductsOverview();
            updateAllCharts();
            
            console.log('üîÑ Filters gereset naar originele staat');
        }
        
        /**
         * Reset all filters and selections to show all products
         */
        function resetAllFilters() {
            // Clear product selection
            selectedProducts.clear();
            productSelectionMode = false;
            
            // Reset active filters
            activeFilters = {};
            
            // Reset to original data
            filteredData = [...originalData];
            
            // Reset all checkboxes to checked state
            document.querySelectorAll('.multiselect input[type="checkbox"]').forEach(checkbox => {
                checkbox.checked = true;
            });
            
            // Reset all select dropdowns to first option
            document.querySelectorAll('.filter-group select').forEach(select => {
                select.selectedIndex = 0;
            });
            
            // Update all components
            updateAllCharts();
            updateStatistics();
            updateProductsOverview();
            updateColorLegend();
            
            console.log('üîÑ Alle filters gereset naar originele staat');
        }

        /**
         * AI Transformation Functions
         */
        
        // Toggle AI transform input visibility for a specific column
        function toggleAITransform(column) {
            console.log(`üîç toggleAITransform aangeroepen voor kolom: ${column}`);
            const inputField = document.getElementById(`ai-input-${column}`);
            const applyButton = document.getElementById(`ai-apply-${column}`);
            
            if (!inputField || !applyButton) {
                console.error(`‚ùå Kon AI elementen niet vinden voor kolom: ${column}`, {
                    inputField: inputField,
                    applyButton: applyButton
                });
                return;
            }
            
            if (inputField.style.display === 'none') {
                inputField.style.display = 'block';
                applyButton.style.display = 'block';
                console.log(`‚úÖ AI input velden weergegeven voor kolom: ${column}`);
            } else {
                inputField.style.display = 'none';
                applyButton.style.display = 'none';
                console.log(`‚úÖ AI input velden verborgen voor kolom: ${column}`);
            }
        }
        
        // Apply AI transformation to column based on user instructions
        async function applyAITransform(column) {
            console.log(`üõ†Ô∏è applyAITransform aangeroepen voor kolom: ${column}`);
            
            const inputField = document.getElementById(`ai-input-${column}`);
            const statusField = document.getElementById(`ai-status-${column}`);
            
            if (!inputField || !statusField) {
                console.error(`‚ùå Kon AI-elementen niet vinden voor kolom: ${column}`, {
                    inputField: inputField,
                    statusField: statusField
                });
                alert(`Fout: Kon AI-elementen niet vinden voor kolom: ${column}`);
                return;
            }
            
            const instructions = inputField.value.trim();
            console.log(`Instructies: "${instructions}"`);
            
            if (!instructions) {
                statusField.innerHTML = '<span class="ai-error">‚ö†Ô∏è Instructie ontbreekt</span>';
                console.warn(`‚ö†Ô∏è Geen instructies ingevoerd voor kolom: ${column}`);
                return;
            }
            
            if (!OPENAI_CONFIG.API_KEY || OPENAI_CONFIG.API_KEY === 'YOUR_OPENAI_API_KEY') {
                statusField.innerHTML = '<span class="ai-error">‚ö†Ô∏è OpenAI API Key ontbreekt</span>';
                console.error(`‚ùå OpenAI API Key ontbreekt of is niet geconfigureerd`);
                alert('OpenAI API Key ontbreekt. Voeg deze toe in de code om AI transformaties te gebruiken.');
                return;
            }
            
            // Get values for this column
            const columnValues = originalData.map(item => item[column]).filter(Boolean);
            console.log(`Kolom '${column}' heeft ${columnValues.length} unieke waarden:`, columnValues.slice(0, 5));
            
            if (columnValues.length === 0) {
                statusField.innerHTML = '<span class="ai-error">‚ö†Ô∏è Geen data om te transformeren</span>';
                console.warn(`‚ö†Ô∏è Geen data gevonden voor kolom: ${column}`);
                return;
            }
            
            // Show loading status
            statusField.innerHTML = '<span class="ai-loading">‚è≥ Transformatie uitvoeren...</span>';
            console.log(`‚è≥ Start API aanroep voor kolom: ${column}`);
            
            try {
                // Transform data with AI
                console.time('AI API aanroep');
                const transformedValues = await transformDataWithAI(column, instructions, columnValues);
                console.timeEnd('AI API aanroep');
                
                // Uitgebreide validatie van resultaat
                console.log('Resultaat type:', typeof transformedValues, 
                          'Is array?', Array.isArray(transformedValues), 
                          'Voorbeeld waarden:', transformedValues ? 
                            (Array.isArray(transformedValues) ? transformedValues.slice(0, 5) : transformedValues) : 'null');
                
                // Controleer of het resultaat bestaat
                if (!transformedValues) {
                    statusField.innerHTML = '<span class="ai-error">‚ùå Transformatie mislukt</span>';
                    console.error(`‚ùå Transformatie voor kolom ${column} mislukt: geen waarden geretourneerd`);
                    alert(`Transformatie mislukt: geen waarden geretourneerd voor kolom ${column}`);
                    return;
                }
                
                // Controleer of het resultaat een array is
                if (!Array.isArray(transformedValues)) {
                    statusField.innerHTML = '<span class="ai-error">‚ùå Ongeldige transformatie</span>';
                    console.error(`‚ùå Transformatie voor kolom ${column} retourneerde geen array:`, transformedValues);
                    alert(`Transformatie voor kolom ${column} retourneerde geen geldig resultaat`);
                    return;
                }
                
                // Controleer of de array voldoende waarden bevat
                if (transformedValues.length === 0) {
                    statusField.innerHTML = '<span class="ai-error">‚ùå Geen waarden gegenereerd</span>';
                    console.error(`‚ùå Transformatie voor kolom ${column} genereerde een lege array`);
                    alert(`Transformatie voor kolom ${column} genereerde geen waarden`);
                    return;
                }
                
                // Update data with transformation
                console.log(`üìù Bijwerken van ${columnValues.length} waarden in kolom ${column}`);
                updateColumnWithTransformedData(column, columnValues, transformedValues);
                
                // Store transformation for reuse
                columnTransformations[column] = instructions;
                transformedColumns.add(column);
                
                statusField.innerHTML = '<span class="ai-success">‚úÖ Transformatie voltooid!</span>';
                console.log(`‚úÖ Transformatie voor kolom ${column} voltooid`);
                
                // Hide inputs after successful transformation
                setTimeout(() => {
                    inputField.style.display = 'none';
                    document.getElementById(`ai-apply-${column}`).style.display = 'none';
                }, 1500);
                
            } catch (error) {
                console.error(`‚ùå AI transformatie fout voor kolom ${column}:`, error);
                statusField.innerHTML = `<span class="ai-error">‚ùå Fout: ${error.message}</span>`;
                alert(`Er is een fout opgetreden bij het transformeren van kolom ${column}: ${error.message}`);
            }
        }
        
        // Transform data using OpenAI API
        async function transformDataWithAI(column, instructions, data) {
            console.log(`üß† Start transformatie van kolom '${column}' met instructie: "${instructions}"`);
            
            // Sample of data for context (up to 20 items)
            const sampleData = data;
            console.log(`üìä Voorbeelddata (${sampleData.length} items):`, sampleData);
            
            try {
                // Prepare the prompt for OpenAI
                const prompt = {
                    model: OPENAI_CONFIG.MODEL,
                    messages: [
                        {
                            role: "system",
                            content: `Je bent een data transformatie assistent voor een dashboard. Je taak is om waarden van het type '${column}' te transformeren volgens gebruikersinstructies. 
                            Retourneer ALLEEN een JSON array met getransformeerde waarden in dezelfde volgorde als de input. 
                            Geef geen uitleg of extra tekst. De output moet een geldige JSON array zijn die direct geparsed kan worden.`
                        },
                        {
                            role: "user",
                            content: `Transformeer de volgende '${column}' waarden volgens deze instructie: "${instructions}"

							Originele waarden: ${JSON.stringify(sampleData)}

							BELANGRIJK: Retourneer EXACT ${sampleData.length} getransformeerde waarden in dezelfde volgorde als de input.
							Retourneer ALLEEN een JSON array met de getransformeerde waarden, zonder uitleg of markdown.`
                        }
                    ],
                    temperature: 0.1,
                    max_tokens: 16000
                };
                
                console.log('üöÄ API aanvraag wordt verzonden...');
                console.log('API URL:', OPENAI_CONFIG.BASE_URL);
                console.log('API Key aanwezig:', OPENAI_CONFIG.API_KEY ? 'Ja (begint met ' + OPENAI_CONFIG.API_KEY.substring(0, 5) + '...)' : 'Nee');
                
                // API aanroep met fetch
                let response;
                try {
                    // Call OpenAI API with timeout
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), 30000); // 30 second timeout
                    
                    response = await fetch(OPENAI_CONFIG.BASE_URL, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${OPENAI_CONFIG.API_KEY}`
                        },
                        body: JSON.stringify(prompt),
                        signal: controller.signal
                    }).finally(() => clearTimeout(timeoutId));
                    
                    if (!response.ok) {
                        let errorDetails = '';
                        try {
                            const errorText = await response.text();
                            errorDetails = errorText;
                            console.error(`‚ùå API error (${response.status}): ${response.statusText}`, errorText);
                        } catch (e) {
                            console.error('Kon error response niet lezen', e);
                        }
                        throw new Error(`API error (${response.status}): ${response.statusText}\n${errorDetails}`);
                    }
                } catch (fetchError) {
                    if (fetchError.name === 'AbortError') {
                        console.error('‚ùå API aanroep timeout na 30 seconden');
                        throw new Error('API aanroep timeout na 30 seconden. Controleer je internetverbinding.');
                    } else if (fetchError.message.includes('Failed to fetch')) {
                        console.error('‚ùå Network error:', fetchError);
                        throw new Error('Netwerkfout bij API aanroep. Controleer je internetverbinding.');
                    } else {
                        console.error('‚ùå Fetch error:', fetchError);
                        throw new Error(`API aanroep fout: ${fetchError.message}`);
                    }
                }
                
                // JSON Response verwerken
                let result;
                try {
                    console.log('‚úÖ API antwoord ontvangen, parsen van JSON...');
                    result = await response.json();
                    console.log('Ruwe API response:', result);
                    
                    if (!result) {
                        throw new Error('API gaf een leeg antwoord');
                    }
                    
                    if (!result.choices || !result.choices[0] || !result.choices[0].message) {
                        console.error('‚ùå Ongeldig API-antwoord formaat:', result);
                        throw new Error('Ongeldig antwoord van API: verwachte velden ontbreken');
                    }
                } catch (jsonError) {
                    console.error('‚ùå Kon API antwoord niet parsen als JSON:', jsonError);
                    throw new Error('Kon API antwoord niet parsen als JSON: ' + jsonError.message);
                }
                
                // Extract JSON array from response
                const content = result.choices[0].message.content.trim();
                console.log('üìù Ontvangen content:', content ? (content.substring(0, 100) + '...') : 'leeg');
                
                if (!content) {
                    throw new Error('API antwoord bevat geen content');
                }
                
                // JSON array parsen
                try {
                    // Handle common JSON parsing issues
                    let cleanedContent = content;
                    
                    // Remove markdown code blocks (```json and ```) if present
                    cleanedContent = cleanedContent.replace(/```json\n|```/g, '');
                    
                    // If content starts with [ and ends with ], we're good
                    if (!cleanedContent.trim().startsWith('[') || !cleanedContent.trim().endsWith(']')) {
                        console.warn('‚ö†Ô∏è Content is not a valid JSON array, trying to extract array...');
                        
                        // Try to extract array from text
                        const arrayMatch = cleanedContent.match(/\[.*\]/s);
                        if (arrayMatch) {
                            cleanedContent = arrayMatch[0];
                            console.log('‚úÖ Array ge√´xtraheerd uit tekst');
                        } else {
                            throw new Error('Geen JSON array gevonden in API-antwoord');
                        }
                    }
                    
                    const parsedData = JSON.parse(cleanedContent);
                    
                    // Controleer of parsedData een array is
                    if (!Array.isArray(parsedData)) {
                        console.error('‚ùå Geparsed resultaat is geen array:', parsedData);
                        throw new Error('API gaf geen geldige array terug');
                    }
                    
                    // Controleer of array niet leeg is
                    if (parsedData.length === 0) {
                        throw new Error('API gaf een lege array terug');
                    }
                    
                    console.log(`‚úÖ Data succesvol geparsed, ${parsedData.length} items`);
                    return parsedData;
                } catch (parseError) {
                    console.error('‚ùå JSON parsing fout:', parseError);
                    console.error('Problematische content:', content);
                    throw new Error(`Kan resultaat niet parsen als JSON: ${parseError.message}`);
                }
            } catch (error) {
                console.error(`‚ùå Transformatie fout voor kolom ${column}:`, error);
                throw error; // Re-throw voor afhandeling in de aanroepende functie
            }
        }
        
        // Update data with transformed values
        function updateColumnWithTransformedData(column, originalValues, transformedValues) {
            console.log(`üîÑ Updating column '${column}' with transformed values`);
            
            // Controleer of alle parameters geldig zijn
            if (!column || !originalValues || !transformedValues) {
                console.error('‚ùå Ongeldige parameters voor updateColumnWithTransformedData:', {
                    column, 
                    hasOriginalValues: Array.isArray(originalValues), 
                    hasTransformedValues: Array.isArray(transformedValues)
                });
                throw new Error('Ongeldige parameters voor kolomtransformatie');
            }
            
            // Zorg dat beide arrays zijn
            if (!Array.isArray(originalValues) || !Array.isArray(transformedValues)) {
                console.error('‚ùå Geen geldige arrays ontvangen:', {
                    originalValues: typeof originalValues,
                    transformedValues: typeof transformedValues
                });
                throw new Error('Transformatie vereist geldige arrays');
            }
            
            // Check als transformedValues leeg is
            if (transformedValues.length === 0) {
                console.error('‚ùå Getransformeerde waarden array is leeg');
                throw new Error('Geen getransformeerde waarden ontvangen van API');
            }
            
            console.log('üîÑ Sample transformations:', originalValues.slice(0, 5).map((val, idx) => {
                return {
                    original: val,
                    transformed: idx < transformedValues.length ? transformedValues[idx] : 'N/A'
                };
            }));
            
            // Create mapping from original to transformed values
            const transformMap = {};
            let transformCount = 0;
            originalValues.forEach((val, index) => {
                if (val !== undefined && val !== null && index < transformedValues.length) {
                    transformMap[val] = transformedValues[index];
                    transformCount++;
                }
            });
            
            console.log(`üîÑ Created mapping for ${transformCount} values`);
            
            // Apply transformation to all data
            let updatedCount = 0;
            originalData.forEach(item => {
                const originalValue = item[column];
                if (originalValue && transformMap[originalValue] !== undefined) {
                    item[column] = transformMap[originalValue];
                    updatedCount++;
                }
            });
            
            console.log(`‚úÖ Updated ${updatedCount} items in originalData`);
            
            // Update filtered data too
            applyFilters(); // Functie roept intern filteredData aan, geen return value nodig
            console.log(`üîç Filters applied, filteredData now has ${filteredData ? filteredData.length : 0} items`);
            
            // Recreate filters to show new values
            console.log('üîÑ Updating filters and charts...');
            
            // Volledige UI update
            createFilters();
            updateStatistics();
            updateProductsOverview();
            updateCharts(); // Alle gewone grafieken
            // updateRelationCharts() verwijderd - functie bestaat niet
            
            console.log(`ü§ñ AI transformatie toegepast op kolom '${column}'`);
            
            // Save state for undo functionality
            saveFilterState();
            
            // Force redraw of critical UI components
            setTimeout(() => {
                // Refresh any charts or dynamic UI elements that might not have updated
                if (typeof updateCharts === 'function') {
                    console.log('üîÑ Forcing chart update...');
                    updateCharts();
                }
                
                // Display notification to user
                const notification = document.createElement('div');
                notification.className = 'notification';
                notification.innerHTML = `<strong>‚úÖ Transformatie toegepast!</strong><br>Kolom '${column}' is getransformeerd.`;
                notification.style.cssText = 'position: fixed; top: 20px; right: 20px; background: #4CAF50; color: white; padding: 15px; border-radius: 5px; box-shadow: 0 2px 10px rgba(0,0,0,0.2); z-index: 1000;';
                document.body.appendChild(notification);
                
                // Remove notification after 3 seconds
                setTimeout(() => {
                    notification.style.opacity = '0';
                    notification.style.transition = 'opacity 0.5s';
                    setTimeout(() => notification.remove(), 500);
                }, 3000);
                
                console.log('‚úÖ UI updates completed');
            }, 100);
        }
        
        // Filter state management for undo functionality
        let filterStateHistory = [];

        function saveFilterState() {
            const currentState = {
                activeFilters: JSON.parse(JSON.stringify(activeFilters)),
                filteredData: [...filteredData],
                originalData: [...originalData],
                columnTransformations: JSON.parse(JSON.stringify(columnTransformations)),
                transformedColumns: new Set([...transformedColumns]),
                timestamp: Date.now()
            };
            
            filterStateHistory.push(currentState);
            
            // Keep only last 10 states to prevent memory issues
            if (filterStateHistory.length > 10) {
                filterStateHistory.shift();
            }
            
            console.log('üìñ Filter state saved:', currentState);
        }

        function restoreFilterState() {
            if (filterStateHistory.length > 0) {
                const previousState = filterStateHistory.pop();
                
                // Restore all state variables
                activeFilters = previousState.activeFilters;
                filteredData = previousState.filteredData;
                originalData = previousState.originalData;
                columnTransformations = previousState.columnTransformations;
                transformedColumns = previousState.transformedColumns;
                
                // Update UI components
                createFilters();
                updateStatistics();
                updateProductsOverview();
                updateCharts();
                
                console.log('üîÑ Filter state restored:', previousState);
                
                // Show notification
                const notification = document.createElement('div');
                notification.innerHTML = '‚Ü©Ô∏è Laatste actie ongedaan gemaakt';
                notification.style.cssText = 'position: fixed; top: 20px; right: 20px; background: #ff9800; color: white; padding: 15px; border-radius: 5px; box-shadow: 0 2px 10px rgba(0,0,0,0.2); z-index: 1000;';
                document.body.appendChild(notification);
                
                setTimeout(() => {
                    notification.style.opacity = '0';
                    notification.style.transition = 'opacity 0.5s';
                    setTimeout(() => notification.remove(), 500);
                }, 2000);
            } else {
                alert('Geen acties om ongedaan te maken');
            }
        }
    </script>
</body>
</html>